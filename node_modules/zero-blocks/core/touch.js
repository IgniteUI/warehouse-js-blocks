"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var core_1 = require('@angular/core');
var EVENT_SUFFIX = "precise";
/**
 * Touch gestures manager based on Hammer.js
 * Use with caution, this will track references for single manager per element. Very TBD. Much TODO.
 */
var HammerGesturesManager = (function () {
    function HammerGesturesManager(_zone) {
        this._zone = _zone;
        this._hammerManagers = [];
        /**
         * Event option defaults for each recognizer, see http://hammerjs.github.io/api/ for API listing.
         */
        this.hammerOptions = [
            {
                name: "pan",
                options: {
                    threshold: 0
                }
            }, {
                name: "pinch",
                options: {
                    enable: true
                }
            }, {
                name: "rotate",
                options: {
                    enable: true
                }
            }];
    }
    HammerGesturesManager.prototype.supports = function (eventName) {
        return eventName.toLowerCase().endsWith("." + EVENT_SUFFIX);
    };
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     */
    HammerGesturesManager.prototype.addEventListener = function (element, eventName, eventHandler, options) {
        if (options === void 0) { options = null; }
        var self = this;
        // Creating the manager bind events, must be done outside of angular
        return this._zone.runOutsideAngular(function () {
            // new Hammer is a shortcut for Manager with defaults
            var mc = new Hammer(element);
            for (var i = 0; i < self.hammerOptions.length; i++) {
                mc.get(self.hammerOptions[i].name).set(self.hammerOptions[i].options);
            }
            var handler = function (eventObj) { self._zone.run(function () { eventHandler(eventObj); }); };
            mc.on(eventName, handler);
            return function () { mc.off(eventName, handler); };
        });
    };
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     *
     * @param target Can be one of either window, body or document(fallback default).
     */
    HammerGesturesManager.prototype.addGlobalEventListener = function (target, eventName, eventHandler) {
        var self = this, element = this.getGlobalEventTarget(target);
        // Creating the manager bind events, must be done outside of angular
        return this._zone.runOutsideAngular(function () {
            // new Hammer is a shortcut for Manager with defaults
            var mc = new Hammer(element);
            self.addManagerForElement(element, mc);
            for (var i = 0; i < self.hammerOptions.length; i++) {
                mc.get(self.hammerOptions[i].name).set(self.hammerOptions[i].options);
            }
            var handler = function (eventObj) {
                self._zone.run(function () {
                    eventHandler(eventObj);
                });
            };
            mc.on(eventName, handler);
            return function () { mc.off(eventName, handler); };
        });
    };
    /** temp replacement for DOM.getGlobalEventTarget(target) because DI won't play nice for now */
    HammerGesturesManager.prototype.getGlobalEventTarget = function (target) {
        switch (target) {
            case "window":
                return window;
            case "body":
                return document.body;
            default:
                return document;
        }
    };
    /**
     * Set HammerManager options.
     *
     * @param element The DOM element used to create the manager on.
     *
     * ### Example
     *
     * ```ts
     * manager.setManagerOption(myElem, "pan", { pointers: 1 });
     * ```
     */
    HammerGesturesManager.prototype.setManagerOption = function (element, event, options) {
        var manager = this.getManagerForElement(element);
        manager.get(event).set(options);
    };
    /**
     * Add an element and manager map to the internal collection.
     *
     * @param element The DOM element used to create the manager on.
     */
    HammerGesturesManager.prototype.addManagerForElement = function (element, manager) {
        this._hammerManagers.push({ element: element, manager: manager });
    };
    /**
     * Get HammerManager for the element or null
     *
     * @param element The DOM element used to create the manager on.
     */
    HammerGesturesManager.prototype.getManagerForElement = function (element) {
        var result = this._hammerManagers.filter(function (value, index, array) {
            return value.element === element;
        });
        return result.length ? result[0].manager : null;
    };
    /**
     * Destroys the HammerManager for the element, removing event listeners in the process.
     *
     * @param element The DOM element used to create the manager on.
     */
    HammerGesturesManager.prototype.removeManagerForElement = function (element) {
        var index = null;
        for (var i = 0; i < this._hammerManagers.length; i++) {
            if (element === this._hammerManagers[i].element) {
                index = i;
                break;
            }
        }
        if (index !== null) {
            var item = this._hammerManagers.splice(index, 1)[0];
            // destroy also
            item.manager.destroy();
        }
    };
    /** Destroys all internally tracked HammerManagers, removing event listeners in the process. */
    HammerGesturesManager.prototype.destroy = function () {
        for (var i = 0; i < this._hammerManagers.length; i++) {
            this._hammerManagers[i].manager.destroy();
        }
        this._hammerManagers = [];
    };
    HammerGesturesManager = __decorate([
        core_1.Injectable(), 
        __metadata('design:paramtypes', [core_1.NgZone])
    ], HammerGesturesManager);
    return HammerGesturesManager;
}());
exports.HammerGesturesManager = HammerGesturesManager;

//# sourceMappingURL=data:application/json;charset=utf8;base64,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LENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwRCxlQUFlO1lBQ2YsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUMzQixDQUFDO0lBQ0wsQ0FBQztJQUVELCtGQUErRjtJQUMvRix1Q0FBTyxHQUFQO1FBQ0ksR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQ25ELElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzlDLENBQUM7UUFDRCxJQUFJLENBQUMsZUFBZSxHQUFHLEVBQUUsQ0FBQztJQUM5QixDQUFDO0lBL0pMO1FBQUMsaUJBQVUsRUFBRTs7NkJBQUE7SUFnS2IsNEJBQUM7QUFBRCxDQS9KQSxBQStKQyxJQUFBO0FBL0pZLDZCQUFxQix3QkErSmpDLENBQUEiLCJmaWxlIjoiY29yZS90b3VjaC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW5qZWN0YWJsZSwgTmdab25lfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuY29uc3QgRVZFTlRfU1VGRklYOiBzdHJpbmcgPSBcInByZWNpc2VcIjtcblxuXG4vKipcbiAqIFRvdWNoIGdlc3R1cmVzIG1hbmFnZXIgYmFzZWQgb24gSGFtbWVyLmpzXG4gKiBVc2Ugd2l0aCBjYXV0aW9uLCB0aGlzIHdpbGwgdHJhY2sgcmVmZXJlbmNlcyBmb3Igc2luZ2xlIG1hbmFnZXIgcGVyIGVsZW1lbnQuIFZlcnkgVEJELiBNdWNoIFRPRE8uXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBIYW1tZXJHZXN0dXJlc01hbmFnZXIge1xuICAgIHByaXZhdGUgX2hhbW1lck1hbmFnZXJzOiBBcnJheTx7IGVsZW1lbnQ6IEV2ZW50VGFyZ2V0LCBtYW5hZ2VyOiBIYW1tZXJNYW5hZ2VyOyB9PiA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgb3B0aW9uIGRlZmF1bHRzIGZvciBlYWNoIHJlY29nbml6ZXIsIHNlZSBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL2FwaS8gZm9yIEFQSSBsaXN0aW5nLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBoYW1tZXJPcHRpb25zOiBBcnJheTxhbnk+ID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcInBhblwiLFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcInBpbmNoXCIsXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwicm90YXRlXCIsXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1dO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfem9uZTogTmdab25lKSB7XG4gICAgfVxuXG4gICAgc3VwcG9ydHMoZXZlbnROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFwiLlwiICsgRVZFTlRfU1VGRklYKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgbGlzdGVuZXIgZXh0ZW5kZWQgd2l0aCBvcHRpb25zIGZvciBIYW1tZXIuanMuIFdpbGwgdXNlIGRlZmF1bHRzIGlmIG5vbmUgYXJlIHByb3ZpZGVkLlxuICAgICAqIE1vZGVsaW5nIGFmdGVyIG90aGVyIGV2ZW50IHBsdWdpbnMgZm9yIGVhc3kgZnV0dXJlIG1vZGlmaWNhdGlvbnMuXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50OiBIVE1MRWxlbWVudCwgZXZlbnROYW1lOiBzdHJpbmcsIGV2ZW50SGFuZGxlcjogRnVuY3Rpb24sIG9wdGlvbnM6IE9iamVjdCA9IG51bGwpOiBGdW5jdGlvbiB7XG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcblxuXG4gICAgICAgIC8vIENyZWF0aW5nIHRoZSBtYW5hZ2VyIGJpbmQgZXZlbnRzLCBtdXN0IGJlIGRvbmUgb3V0c2lkZSBvZiBhbmd1bGFyXG4gICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gbmV3IEhhbW1lciBpcyBhIHNob3J0Y3V0IGZvciBNYW5hZ2VyIHdpdGggZGVmYXVsdHNcbiAgICAgICAgICAgIHZhciBtYyA9IG5ldyBIYW1tZXIoZWxlbWVudCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuaGFtbWVyT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG1jLmdldChzZWxmLmhhbW1lck9wdGlvbnNbaV0ubmFtZSkuc2V0KHNlbGYuaGFtbWVyT3B0aW9uc1tpXS5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24oZXZlbnRPYmopIHsgc2VsZi5fem9uZS5ydW4oZnVuY3Rpb24oKSB7IGV2ZW50SGFuZGxlcihldmVudE9iaik7IH0pOyB9O1xuICAgICAgICAgICAgbWMub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7IG1jLm9mZihldmVudE5hbWUsIGhhbmRsZXIpOyB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgbGlzdGVuZXIgZXh0ZW5kZWQgd2l0aCBvcHRpb25zIGZvciBIYW1tZXIuanMuIFdpbGwgdXNlIGRlZmF1bHRzIGlmIG5vbmUgYXJlIHByb3ZpZGVkLlxuICAgICAqIE1vZGVsaW5nIGFmdGVyIG90aGVyIGV2ZW50IHBsdWdpbnMgZm9yIGVhc3kgZnV0dXJlIG1vZGlmaWNhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IENhbiBiZSBvbmUgb2YgZWl0aGVyIHdpbmRvdywgYm9keSBvciBkb2N1bWVudChmYWxsYmFjayBkZWZhdWx0KS5cbiAgICAgKi9cbiAgICBhZGRHbG9iYWxFdmVudExpc3RlbmVyKHRhcmdldDogc3RyaW5nLCBldmVudE5hbWU6IHN0cmluZywgZXZlbnRIYW5kbGVyOiBGdW5jdGlvbik6IEZ1bmN0aW9uIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMuZ2V0R2xvYmFsRXZlbnRUYXJnZXQodGFyZ2V0KTtcblxuICAgICAgICAvLyBDcmVhdGluZyB0aGUgbWFuYWdlciBiaW5kIGV2ZW50cywgbXVzdCBiZSBkb25lIG91dHNpZGUgb2YgYW5ndWxhclxuICAgICAgICByZXR1cm4gdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG5ldyBIYW1tZXIgaXMgYSBzaG9ydGN1dCBmb3IgTWFuYWdlciB3aXRoIGRlZmF1bHRzXG5cbiAgICAgICAgICAgIHZhciBtYyA6IEhhbW1lck1hbmFnZXIgPSBuZXcgSGFtbWVyKGVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgc2VsZi5hZGRNYW5hZ2VyRm9yRWxlbWVudChlbGVtZW50IGFzIEhUTUxFbGVtZW50LCBtYyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5oYW1tZXJPcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWMuZ2V0KHNlbGYuaGFtbWVyT3B0aW9uc1tpXS5uYW1lKS5zZXQoc2VsZi5oYW1tZXJPcHRpb25zW2ldLm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbihldmVudE9iaikge1xuICAgICAgICAgICAgICAgIHNlbGYuX3pvbmUucnVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIoZXZlbnRPYmopO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1jLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4geyBtYy5vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTsgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIHRlbXAgcmVwbGFjZW1lbnQgZm9yIERPTS5nZXRHbG9iYWxFdmVudFRhcmdldCh0YXJnZXQpIGJlY2F1c2UgREkgd29uJ3QgcGxheSBuaWNlIGZvciBub3cgKi9cbiAgICBnZXRHbG9iYWxFdmVudFRhcmdldCh0YXJnZXQ6IHN0cmluZyk6IEV2ZW50VGFyZ2V0IHtcbiAgICAgICAgc3dpdGNoICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ3aW5kb3dcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTZXQgSGFtbWVyTWFuYWdlciBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIERPTSBlbGVtZW50IHVzZWQgdG8gY3JlYXRlIHRoZSBtYW5hZ2VyIG9uLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbWFuYWdlci5zZXRNYW5hZ2VyT3B0aW9uKG15RWxlbSwgXCJwYW5cIiwgeyBwb2ludGVyczogMSB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXRNYW5hZ2VyT3B0aW9uKGVsZW1lbnQ6IEV2ZW50VGFyZ2V0LCBldmVudDogc3RyaW5nLCBvcHRpb25zOiBhbnkpIHtcbiAgICAgICAgdmFyIG1hbmFnZXIgPSB0aGlzLmdldE1hbmFnZXJGb3JFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICBtYW5hZ2VyLmdldChldmVudCkuc2V0KG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBlbGVtZW50IGFuZCBtYW5hZ2VyIG1hcCB0byB0aGUgaW50ZXJuYWwgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IFRoZSBET00gZWxlbWVudCB1c2VkIHRvIGNyZWF0ZSB0aGUgbWFuYWdlciBvbi5cbiAgICAgKi9cbiAgICBhZGRNYW5hZ2VyRm9yRWxlbWVudChlbGVtZW50OiBFdmVudFRhcmdldCwgbWFuYWdlcjogSGFtbWVyTWFuYWdlcikge1xuICAgICAgICB0aGlzLl9oYW1tZXJNYW5hZ2Vycy5wdXNoKHtlbGVtZW50OiBlbGVtZW50LCBtYW5hZ2VyOiBtYW5hZ2VyfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IEhhbW1lck1hbmFnZXIgZm9yIHRoZSBlbGVtZW50IG9yIG51bGxcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IFRoZSBET00gZWxlbWVudCB1c2VkIHRvIGNyZWF0ZSB0aGUgbWFuYWdlciBvbi5cbiAgICAgKi9cbiAgICBnZXRNYW5hZ2VyRm9yRWxlbWVudChlbGVtZW50OiBFdmVudFRhcmdldCkgOiBIYW1tZXJNYW5hZ2VyIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICB0aGlzLl9oYW1tZXJNYW5hZ2Vycy5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5lbGVtZW50ID09PSBlbGVtZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPyByZXN1bHRbMF0ubWFuYWdlciA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIEhhbW1lck1hbmFnZXIgZm9yIHRoZSBlbGVtZW50LCByZW1vdmluZyBldmVudCBsaXN0ZW5lcnMgaW4gdGhlIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgRE9NIGVsZW1lbnQgdXNlZCB0byBjcmVhdGUgdGhlIG1hbmFnZXIgb24uXG4gICAgICovXG4gICAgcmVtb3ZlTWFuYWdlckZvckVsZW1lbnQoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgbGV0IGluZGV4OiBudW1iZXIgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hhbW1lck1hbmFnZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZihlbGVtZW50ID09PSB0aGlzLl9oYW1tZXJNYW5hZ2Vyc1tpXS5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9oYW1tZXJNYW5hZ2Vycy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuICAgICAgICAgICAgLy8gZGVzdHJveSBhbHNvXG4gICAgICAgICAgICBpdGVtLm1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIERlc3Ryb3lzIGFsbCBpbnRlcm5hbGx5IHRyYWNrZWQgSGFtbWVyTWFuYWdlcnMsIHJlbW92aW5nIGV2ZW50IGxpc3RlbmVycyBpbiB0aGUgcHJvY2Vzcy4gKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hhbW1lck1hbmFnZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW1tZXJNYW5hZ2Vyc1tpXS5tYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oYW1tZXJNYW5hZ2VycyA9IFtdO1xuICAgIH1cbn1cblxuIl19
