"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var core_1 = require('@angular/core');
// import {AnimationBuilder} from 'angular2/src/animate/animation_builder'; TODO
var base_1 = require('../core/base');
var touch_1 = require("../core/touch");
var navigation_1 = require('../core/navigation');
/**
 * Navigation Drawer component supports collapsible side navigation container.
 * Usage:
 * ```
 * <ig-nav-drawer id="ID" (event output bindings) [input bindings]>
 *  <div class="ig-drawer-content">
 *   <!-- expanded template -->
 *  </div>
 * </ig-nav-drawer>
 * ```
 * Can also include an optional `<div class="ig-drawer-mini-content">`.
 * ID required to register with NavigationService allow directives to target the control.
 */
var NavigationDrawer = (function (_super) {
    __extends(NavigationDrawer, _super);
    function NavigationDrawer(elementRef, _state, 
        // private animate: AnimationBuilder, TODO
        renderer, _touchManager) {
        var _this = this;
        _super.call(this, renderer);
        this.elementRef = elementRef;
        this._state = _state;
        this.renderer = renderer;
        this._touchManager = _touchManager;
        this._hasMimiTempl = false;
        this._swipeAttached = false;
        this._widthCache = { width: null, miniWidth: null };
        this.css = {
            "drawer": "ig-nav-drawer",
            "overlay": "ig-nav-drawer-overlay",
            "mini": "mini",
            "miniProjection": ".ig-drawer-mini-content",
            "styleDummy": "style-dummy"
        };
        /** Pan animation properties */
        this._panning = false;
        this._maxEdgeZone = 50;
        /**
         * Position of the Navigation Drawer. Can be "left"(default) or "right". Only has effect when not pinned.
         */
        this.position = "left";
        /**
         * Enables the use of touch gestures to manipulate the drawer - such as swipe/pan from edge to open, swipe toggle and pan drag.
         */
        this.enableGestures = true;
        /** State of the drawer. */
        this.isOpen = false;
        /** Pinned state of the drawer. Currently only support  */
        this.pin = false;
        /** Minimum device width required for automatic pin to be toggled. Deafult is 1024, can be set to falsy value to ignore. */
        this.pinThreshold = 1024;
        /** Event fired as the Navigation Drawer is about to open. */
        this.opening = new core_1.EventEmitter();
        /** Event fired when the Navigation Drawer has opened. */
        this.opened = new core_1.EventEmitter();
        /** Event fired as the Navigation Drawer is about to close. */
        this.closing = new core_1.EventEmitter();
        /** Event fired when the Navigation Drawer has closed. */
        this.closed = new core_1.EventEmitter();
        this.swipe = function (evt) {
            // TODO: Could also force input type: http://stackoverflow.com/a/27108052
            if (!_this.enableGestures || evt.pointerType !== "touch") {
                return;
            }
            // HammerJS swipe is horizontal-only by default, don't check deltaY
            var deltaX, startPosition;
            if (_this.position === "right") {
                // when on the right use inverse of deltaX
                deltaX = -evt.deltaX;
                startPosition = _this.getWindowWidth() - (evt.center.x + evt.distance);
            }
            else {
                deltaX = evt.deltaX;
                startPosition = evt.center.x - evt.distance;
            }
            //only accept closing swipe (ignoring minEdgeZone) when the drawer is expanded:
            if ((_this.isOpen && deltaX < 0) ||
                // positive deltaX from the edge:
                (deltaX > 0 && startPosition < _this.maxEdgeZone)) {
                _this.toggle(true);
            }
        };
        this.panstart = function (evt) {
            if (!_this.enableGestures || _this.pin || evt.pointerType !== "touch") {
                return;
            }
            var startPosition = _this.position === "right" ? _this.getWindowWidth() - (evt.center.x + evt.distance) : evt.center.x - evt.distance;
            // cache width during animation, flag to allow further handling
            if (_this.isOpen || (startPosition < _this.maxEdgeZone)) {
                _this._panning = true;
                _this._panStartWidth = _this.getExpectedWidth(!_this.isOpen);
                _this._panLimit = _this.getExpectedWidth(_this.isOpen);
                _this.renderer.setElementClass(_this.overlay, "panning", true);
                _this.renderer.setElementClass(_this.drawer, "panning", true);
            }
        };
        this.pan = function (evt) {
            // TODO: input.deltaX = prevDelta.x + (center.x - offset.x); get actual delta (not total session one) from event?
            // pan WILL also fire after a full swipe, only resize on flag
            if (!_this._panning) {
                return;
            }
            var right = _this.position === "right", 
            // when on the right use inverse of deltaX
            deltaX = right ? -evt.deltaX : evt.deltaX, visibleWidth, newX, percent;
            visibleWidth = _this._panStartWidth + deltaX;
            if (_this.isOpen && deltaX < 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth <= _this._panLimit)
                    return;
                if (_this.hasAnimateWidth) {
                    percent = (visibleWidth - _this._panLimit) / (_this._panStartWidth - _this._panLimit);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / _this._panStartWidth;
                    newX = evt.deltaX;
                }
                _this.setXSize(newX, percent.toPrecision(2));
            }
            else if (!_this.isOpen && deltaX > 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth >= _this._panLimit)
                    return;
                if (_this.hasAnimateWidth) {
                    percent = (visibleWidth - _this._panStartWidth) / (_this._panLimit - _this._panStartWidth);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / _this._panLimit;
                    newX = (_this._panLimit - visibleWidth) * (right ? 1 : -1);
                }
                _this.setXSize(newX, percent.toPrecision(2));
            }
        };
        this.panEnd = function (evt) {
            if (_this._panning) {
                var deltaX = _this.position === "right" ? -evt.deltaX : evt.deltaX, visibleWidth = _this._panStartWidth + deltaX;
                _this.resetPan();
                // check if pan brought the drawer to 50%
                if (_this.isOpen && visibleWidth <= _this._panStartWidth / 2) {
                    _this.close(true);
                }
                else if (!_this.isOpen && visibleWidth >= _this._panLimit / 2) {
                    _this.open(true);
                }
                _this._panStartWidth = null;
            }
        };
        this.toggleOpenedEvent = function (evt) {
            _this.elementRef.nativeElement.removeEventListener("transitionend", _this.toggleOpenedEvent, false);
            _this._resolveOpen("opened");
            delete _this._resolveClose;
        };
        this.toggleClosedEvent = function (evt) {
            _this.elementRef.nativeElement.removeEventListener("transitionend", _this.toggleClosedEvent, false);
            _this._resolveClose("closed");
            delete _this._resolveClose;
        };
    }
    Object.defineProperty(NavigationDrawer.prototype, "drawer", {
        get: function () {
            if (!this._drawer) {
                this._drawer = this.getChild("." + this.css["drawer"]);
            }
            return this._drawer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationDrawer.prototype, "overlay", {
        get: function () {
            if (!this._overlay) {
                this._overlay = this.getChild("." + this.css["overlay"]);
            }
            return this._overlay;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationDrawer.prototype, "styleDummy", {
        get: function () {
            if (!this._styleDummy) {
                this._styleDummy = this.getChild("." + this.css["styleDummy"]);
            }
            return this._styleDummy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationDrawer.prototype, "hasAnimateWidth", {
        /**
         * Property to decide whether to change width or translate the drawer from pan gesture.
         */
        get: function () {
            return this.pin || this._hasMimiTempl;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationDrawer.prototype, "maxEdgeZone", {
        /**
         * Used for touch gestures (swipe and pan). Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
         * @protected set method
         */
        get: function () {
            return this._maxEdgeZone;
        },
        enumerable: true,
        configurable: true
    });
    NavigationDrawer.prototype.set_maxEdgeZone = function (value) {
        this._maxEdgeZone = value;
    };
    Object.defineProperty(NavigationDrawer.prototype, "expectedWidth", {
        /**
         * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
         */
        get: function () {
            return this.getExpectedWidth(false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationDrawer.prototype, "expectedMiniWidth", {
        /**
         * Get the Drawer mini width for specific state. Will attempt to evaluate requested state and cache.
         */
        get: function () {
            return this.getExpectedWidth(true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationDrawer.prototype, "touchManager", {
        get: function () {
            return this._touchManager;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationDrawer.prototype, "state", {
        /**
         * Exposes optional navigation service
         */
        get: function () {
            return this._state;
        },
        enumerable: true,
        configurable: true
    });
    NavigationDrawer.prototype.ngOnInit = function () {
        // DOM and @Input()-s initialized
        if (this._state) {
            this._state.add(this.id, this);
        }
    };
    NavigationDrawer.prototype.ngAfterContentInit = function () {
        // wait for template and ng-content to be ready
        this._hasMimiTempl = this.getChild(this.css["miniProjection"]) !== null;
        this.updateEdgeZone();
        if (this.pinThreshold && this.getWindowWidth() > this.pinThreshold) {
            this.pin = true;
        }
        // need to set height without absolute positioning
        this.ensureDrawerHeight();
        this.ensureEvents();
        // TODO: apply platform-safe Ruler from http://plnkr.co/edit/81nWDyreYMzkunihfRgX?p=preview
        // (https://github.com/angular/angular/issues/6515), blocked by https://github.com/angular/angular/issues/6904
    };
    NavigationDrawer.prototype.ngOnDestroy = function () {
        this._touchManager.destroy();
        if (this._state) {
            this._state.remove(this.id);
        }
    };
    NavigationDrawer.prototype.ngOnChanges = function (changes) {
        // simple settings can come from attribute set (rather than binding), make sure boolean props are converted
        if (changes['enableGestures'] && changes['enableGestures'].currentValue !== undefined) {
            this.enableGestures = !!(this.enableGestures && this.enableGestures.toString() === "true");
            this.ensureEvents();
        }
        if (changes['pin'] && changes['pin'].currentValue !== undefined) {
            this.pin = !!(this.pin && this.pin.toString() === "true");
            this.ensureDrawerHeight();
            if (this.pin) {
                this._touchManager.destroy();
            }
            else {
                this.ensureEvents();
            }
        }
        if (changes['width'] && this.isOpen) {
            this.setDrawerWidth(changes['width'].currentValue);
        }
        if (changes['miniWidth']) {
            if (!this.isOpen) {
                this.setDrawerWidth(changes['miniWidth'].currentValue);
            }
            this.updateEdgeZone();
        }
    };
    NavigationDrawer.prototype.getWindowWidth = function () {
        return (window.innerWidth > 0) ? window.innerWidth : screen.width;
    };
    /**
     * Sets the drawer width.
     * @param width Width to set, must be valid CSS size string.
     */
    NavigationDrawer.prototype.setDrawerWidth = function (width) {
        var _this = this;
        window.requestAnimationFrame(function () {
            if (_this.drawer) {
                _this.renderer.setElementStyle(_this.drawer, "width", width);
            }
        });
    };
    NavigationDrawer.prototype.ensureDrawerHeight = function () {
        if (this.pin) {
            // TODO: nested in content?
            // setElementStyle warning https://github.com/angular/angular/issues/6563
            this.renderer.setElementStyle(this.drawer, "height", window.innerHeight + "px");
        }
    };
    /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     * @param mini Request mini width instead
     */
    NavigationDrawer.prototype.getExpectedWidth = function (mini) {
        if (mini) {
            if (!this._hasMimiTempl) {
                return 0;
            }
            if (this.miniWidth) {
                return parseFloat(this.miniWidth);
            }
            else {
                // if (!this.isOpen) { // This WON'T work due to transition timings...
                //     return this.elementRef.nativeElement.children[1].offsetWidth;
                // } else {
                if (this._widthCache["miniWidth"] === null) {
                    // force class for width calc. TODO?
                    this.renderer.setElementClass(this.styleDummy, this.css["drawer"], true);
                    this.renderer.setElementClass(this.styleDummy, this.css["mini"], true);
                    this._widthCache["miniWidth"] = this.styleDummy.offsetWidth;
                    this.renderer.setElementClass(this.styleDummy, this.css["drawer"], false);
                    this.renderer.setElementClass(this.styleDummy, this.css["mini"], false);
                }
                return this._widthCache["miniWidth"];
            }
        }
        else {
            if (this.width) {
                return parseFloat(this.width);
            }
            else {
                if (this._widthCache["width"] === null) {
                    // force class for width calc. TODO?
                    this.renderer.setElementClass(this.styleDummy, this.css["drawer"], true);
                    this._widthCache["width"] = this.styleDummy.offsetWidth;
                    this.renderer.setElementClass(this.styleDummy, this.css["drawer"], false);
                }
                return this._widthCache["width"];
            }
        }
    };
    /**
     * Get current Drawer width.
     */
    NavigationDrawer.prototype.getDrawerWidth = function () {
        return this.drawer.offsetWidth;
    };
    NavigationDrawer.prototype.ensureEvents = function () {
        // set listeners for swipe/pan only if needed, but just once
        if (this.enableGestures && !this.pin && !this._swipeAttached) {
            // Built-in manager handler(L20887) causes endless loop and max stack exception. https://github.com/angular/angular/issues/6993
            // Use ours for now (until beta.10):
            //this.renderer.listen(document, "swipe", this.swipe);
            this._touchManager.addGlobalEventListener("document", "swipe", this.swipe);
            this._swipeAttached = true;
            //this.renderer.listen(document, "panstart", this.panstart);
            //this.renderer.listen(document, "pan", this.pan);
            this._touchManager.addGlobalEventListener("document", "panstart", this.panstart);
            this._touchManager.addGlobalEventListener("document", "panmove", this.pan);
            this._touchManager.addGlobalEventListener("document", "panend", this.panEnd);
        }
    };
    NavigationDrawer.prototype.updateEdgeZone = function () {
        var maxValue;
        if (this._hasMimiTempl) {
            maxValue = Math.max(this._maxEdgeZone, this.getExpectedWidth(true) * 1.1);
            this.set_maxEdgeZone(maxValue);
        }
    };
    NavigationDrawer.prototype.resetPan = function () {
        this._panning = false;
        /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
        this.renderer.setElementClass(this.overlay, "panning", false);
        this.renderer.setElementClass(this.drawer, "panning", false);
        this.setXSize(0, "");
    };
    /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     * @param x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param opacity optional value to apply to the overlay
     */
    NavigationDrawer.prototype.setXSize = function (x, opacity) {
        var _this = this;
        // Angular polyfills patches window.requestAnimationFrame, but switch to DomAdapter API (TODO)
        window.requestAnimationFrame(function () {
            if (_this.hasAnimateWidth) {
                _this.renderer.setElementStyle(_this.drawer, "width", x ? Math.abs(x) + "px" : "");
            }
            else {
                _this.renderer.setElementStyle(_this.drawer, "transform", x ? "translate3d(" + x + "px,0,0)" : "");
                _this.renderer.setElementStyle(_this.drawer, "-webkit-transform", x ? "translate3d(" + x + "px,0,0)" : "");
            }
            if (opacity !== undefined) {
                _this.renderer.setElementStyle(_this.overlay, "opacity", opacity);
            }
        });
    };
    /**
     * Toggle the open state of the Navigation Drawer.
     * @param fireEvents Optional flag determining whether events should be fired or not.
     * @return Promise that is resolved once the operation completes.
     */
    NavigationDrawer.prototype.toggle = function (fireEvents) {
        if (this.isOpen) {
            return this.close(fireEvents);
        }
        else {
            return this.open(fireEvents);
        }
    };
    /**
     * Open the Navigation Drawer. Has no effect if already opened.
     * @param fireEvents Optional flag determining whether events should be fired or not.
     * @return Promise that is resolved once the operation completes.
     */
    NavigationDrawer.prototype.open = function (fireEvents) {
        var _this = this;
        if (this._panning) {
            this.resetPan();
        }
        if (this.isOpen) {
            return Promise.resolve();
        }
        if (fireEvents) {
            this.opening.emit("opening");
        }
        this.isOpen = true;
        // TODO: Switch to animate API when available
        // var animationCss = this.animate.css();
        //     animationCss
        //         .setStyles({'width':'50px'}, {'width':'400px'})
        //         .start(this.elementRef.nativeElement)
        //         .onComplete(() => animationCss.setToStyles({'width':'auto'}).start(this.elementRef.nativeElement));
        this.elementRef.nativeElement.addEventListener("transitionend", this.toggleOpenedEvent, false);
        this.setDrawerWidth(this.width);
        return new Promise(function (resolve) {
            _this._resolveOpen = function (value) {
                resolve(value);
                if (fireEvents) {
                    _this.opened.emit("opened");
                }
            };
        });
    };
    /**
     * Close the Navigation Drawer. Has no effect if already closed.
     * @param fireEvents Optional flag determining whether events should be fired or not.
     * @return Promise that is resolved once the operation completes.
     */
    NavigationDrawer.prototype.close = function (fireEvents) {
        var _this = this;
        if (this._panning) {
            this.resetPan();
        }
        if (!this.isOpen) {
            return Promise.resolve();
        }
        if (fireEvents) {
            this.closing.emit("closing");
        }
        this.isOpen = false;
        this.setDrawerWidth(this._hasMimiTempl ? this.miniWidth : "");
        this.elementRef.nativeElement.addEventListener("transitionend", this.toggleClosedEvent, false);
        return new Promise(function (resolve) {
            _this._resolveClose = function (value) {
                resolve(value);
                if (fireEvents) {
                    _this.closed.emit("closed");
                }
            };
        });
    };
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], NavigationDrawer.prototype, "id", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], NavigationDrawer.prototype, "position", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Boolean)
    ], NavigationDrawer.prototype, "enableGestures", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Boolean)
    ], NavigationDrawer.prototype, "isOpen", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Boolean)
    ], NavigationDrawer.prototype, "pin", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Number)
    ], NavigationDrawer.prototype, "pinThreshold", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], NavigationDrawer.prototype, "width", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], NavigationDrawer.prototype, "miniWidth", void 0);
    __decorate([
        core_1.Output(), 
        __metadata('design:type', Object)
    ], NavigationDrawer.prototype, "opening", void 0);
    __decorate([
        core_1.Output(), 
        __metadata('design:type', Object)
    ], NavigationDrawer.prototype, "opened", void 0);
    __decorate([
        core_1.Output(), 
        __metadata('design:type', Object)
    ], NavigationDrawer.prototype, "closing", void 0);
    __decorate([
        core_1.Output(), 
        __metadata('design:type', Object)
    ], NavigationDrawer.prototype, "closed", void 0);
    NavigationDrawer = __decorate([
        core_1.Component({
            selector: 'ig-nav-drawer',
            /* Per https://github.com/angular/angular/issues/2383 BUT https://github.com/angular/angular/issues/6053, can't use relative URLs still with SystemJS
                TODO: try https://github.com/angular/angular/issues/2991 ??
            */
            moduleId: module.id,
            template: "\n      <div class=\"ig-nav-drawer-overlay\" [class.pinned]=\"pin\" [class.hidden]=\"!isOpen\" (click)=\"close(true)\"></div>\n      <aside class=\"ig-nav-drawer\" role=\"navigation\" \n          [class.collapsed]=\"!_hasMimiTempl && !isOpen\" [class.mini]=\"_hasMimiTempl && !isOpen\" [class.pinned]=\"pin\" [class.right]=\"position == 'right'\">\n    \n          <div class=\"\" [hidden]=\"!isOpen && _hasMimiTempl\">\n              <ng-content select=\".ig-drawer-content\"></ng-content>\n          </div>                \n          <div class=\"\" [hidden]=\"isOpen\">\n              <ng-content select=\".ig-drawer-mini-content\"></ng-content>\n          </div>\n      </aside>\n      <div class=\"style-dummy\"></div>\n    ",
            providers: [touch_1.HammerGesturesManager]
        }),
        __param(0, core_1.Inject(core_1.ElementRef)),
        __param(1, core_1.Optional()), 
        __metadata('design:paramtypes', [core_1.ElementRef, navigation_1.NavigationService, core_1.Renderer, touch_1.HammerGesturesManager])
    ], NavigationDrawer);
    return NavigationDrawer;
}(base_1.BaseComponent));
exports.NavigationDrawer = NavigationDrawer;
var NavigationDrawerModule = (function () {
    function NavigationDrawerModule() {
    }
    NavigationDrawerModule = __decorate([
        core_1.NgModule({
            declarations: [NavigationDrawer],
            exports: [NavigationDrawer]
        }), 
        __metadata('design:paramtypes', [])
    ], NavigationDrawerModule);
    return NavigationDrawerModule;
}());
exports.NavigationDrawerModule = NavigationDrawerModule;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5hdmlnYXRpb24tZHJhd2VyL25hdmlnYXRpb24tZHJhd2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHFCQUFxSyxlQUFlLENBQUMsQ0FBQTtBQUNyTCxnRkFBZ0Y7QUFDaEYscUJBQThCLGNBQWMsQ0FBQyxDQUFBO0FBQzdDLHNCQUFzQyxlQUFlLENBQUMsQ0FBQTtBQUN0RCwyQkFBNEMsb0JBQW9CLENBQUMsQ0FBQTtBQU1qRTs7Ozs7Ozs7Ozs7O0dBWUc7QUF1Qkg7SUFBc0Msb0NBQWE7SUFtSS9DLDBCQUNnQyxVQUFzQixFQUM5QixNQUF5QjtRQUM3QywwQ0FBMEM7UUFDaEMsUUFBaUIsRUFDbkIsYUFBb0M7UUF4SXBELGlCQW1nQkM7UUF6WE8sa0JBQU0sUUFBUSxDQUFDLENBQUM7UUFOWSxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQzlCLFdBQU0sR0FBTixNQUFNLENBQW1CO1FBRW5DLGFBQVEsR0FBUixRQUFRLENBQVM7UUFDbkIsa0JBQWEsR0FBYixhQUFhLENBQXVCO1FBdkl4QyxrQkFBYSxHQUFZLEtBQUssQ0FBQztRQUMvQixtQkFBYyxHQUFZLEtBQUssQ0FBQztRQUNoQyxnQkFBVyxHQUF1QyxFQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBQyxDQUFDO1FBQ2pGLFFBQUcsR0FBZ0M7WUFDdkMsUUFBUSxFQUFHLGVBQWU7WUFDMUIsU0FBUyxFQUFHLHVCQUF1QjtZQUNuQyxNQUFNLEVBQUcsTUFBTTtZQUNmLGdCQUFnQixFQUFHLHlCQUF5QjtZQUM1QyxZQUFZLEVBQUcsYUFBYTtTQUMvQixDQUFDO1FBMkJGLCtCQUErQjtRQUN2QixhQUFRLEdBQVksS0FBSyxDQUFDO1FBWTFCLGlCQUFZLEdBQVcsRUFBRSxDQUFDO1FBeUNsQzs7V0FFRztRQUNhLGFBQVEsR0FBVyxNQUFNLENBQUM7UUFFMUM7O1dBRUc7UUFDYSxtQkFBYyxHQUFZLElBQUksQ0FBQztRQUUvQywy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QkFBVSxDQUFDO21CQUNsQixlQUFRLEVBQUU7O3dCQXRJakI7SUFvZ0JGLHVCQUFDO0FBQUQsQ0FuZ0JBLEFBbWdCQyxDQW5nQnFDLG9CQUFhLEdBbWdCbEQ7QUFuZ0JZLHdCQUFnQixtQkFtZ0I1QixDQUFBO0FBT0Q7SUFBQTtJQUNBLENBQUM7SUFMRDtRQUFDLGVBQVEsQ0FBQztZQUNOLFlBQVksRUFBRSxDQUFDLGdCQUFnQixDQUFDO1lBQ2hDLE9BQU8sRUFBRSxDQUFDLGdCQUFnQixDQUFDO1NBQzlCLENBQUM7OzhCQUFBO0lBRUYsNkJBQUM7QUFBRCxDQURBLEFBQ0MsSUFBQTtBQURZLDhCQUFzQix5QkFDbEMsQ0FBQSIsImZpbGUiOiJuYXZpZ2F0aW9uLWRyYXdlci9uYXZpZ2F0aW9uLWRyYXdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q29tcG9uZW50LCBJbnB1dCwgSW5qZWN0LCBTaW1wbGVDaGFuZ2UsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgT3V0cHV0LCBSZW5kZXJlciwgT25Jbml0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgT3B0aW9uYWwsIEFmdGVyQ29udGVudEluaXQsIE5nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbi8vIGltcG9ydCB7QW5pbWF0aW9uQnVpbGRlcn0gZnJvbSAnYW5ndWxhcjIvc3JjL2FuaW1hdGUvYW5pbWF0aW9uX2J1aWxkZXInOyBUT0RPXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vY29yZS9iYXNlJztcbmltcG9ydCB7IEhhbW1lckdlc3R1cmVzTWFuYWdlciB9IGZyb20gXCIuLi9jb3JlL3RvdWNoXCI7XG5pbXBvcnQge05hdmlnYXRpb25TZXJ2aWNlLCBUb2dnbGVWaWV3fSBmcm9tICcuLi9jb3JlL25hdmlnYXRpb24nO1xuXG4vLyBjb3ZlciBmb3IgdHJhbnNwaWxlciBlcnJvclxuLy8gU3lzdGVtSlMgd2lsbCBldmVudHVhbGx5IHdyYXAgdGhlIGV4cG9ydCBpbiB0aGUgcHJvcGVyIG5vZGUuanMgc3R5bGUgZnVuY3Rpb24gb24gdGhlIGNsaWVudFxuZGVjbGFyZSB2YXIgbW9kdWxlOiBhbnk7XG5cbi8qKlxuICogTmF2aWdhdGlvbiBEcmF3ZXIgY29tcG9uZW50IHN1cHBvcnRzIGNvbGxhcHNpYmxlIHNpZGUgbmF2aWdhdGlvbiBjb250YWluZXIuXG4gKiBVc2FnZTpcbiAqIGBgYFxuICogPGlnLW5hdi1kcmF3ZXIgaWQ9XCJJRFwiIChldmVudCBvdXRwdXQgYmluZGluZ3MpIFtpbnB1dCBiaW5kaW5nc10+XG4gKiAgPGRpdiBjbGFzcz1cImlnLWRyYXdlci1jb250ZW50XCI+XG4gKiAgIDwhLS0gZXhwYW5kZWQgdGVtcGxhdGUgLS0+XG4gKiAgPC9kaXY+XG4gKiA8L2lnLW5hdi1kcmF3ZXI+XG4gKiBgYGBcbiAqIENhbiBhbHNvIGluY2x1ZGUgYW4gb3B0aW9uYWwgYDxkaXYgY2xhc3M9XCJpZy1kcmF3ZXItbWluaS1jb250ZW50XCI+YC5cbiAqIElEIHJlcXVpcmVkIHRvIHJlZ2lzdGVyIHdpdGggTmF2aWdhdGlvblNlcnZpY2UgYWxsb3cgZGlyZWN0aXZlcyB0byB0YXJnZXQgdGhlIGNvbnRyb2wuIFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lnLW5hdi1kcmF3ZXInLFxuICAgIC8qIFBlciBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yMzgzIEJVVCBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy82MDUzLCBjYW4ndCB1c2UgcmVsYXRpdmUgVVJMcyBzdGlsbCB3aXRoIFN5c3RlbUpTXG4gICAgICAgIFRPRE86IHRyeSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yOTkxID8/XG4gICAgKi9cbiAgICBtb2R1bGVJZDogbW9kdWxlLmlkLCAvLyBjb21tb25KUyBzdGFuZGFyZFxuICAgIHRlbXBsYXRlOiBgXG4gICAgICA8ZGl2IGNsYXNzPVwiaWctbmF2LWRyYXdlci1vdmVybGF5XCIgW2NsYXNzLnBpbm5lZF09XCJwaW5cIiBbY2xhc3MuaGlkZGVuXT1cIiFpc09wZW5cIiAoY2xpY2spPVwiY2xvc2UodHJ1ZSlcIj48L2Rpdj5cbiAgICAgIDxhc2lkZSBjbGFzcz1cImlnLW5hdi1kcmF3ZXJcIiByb2xlPVwibmF2aWdhdGlvblwiIFxuICAgICAgICAgIFtjbGFzcy5jb2xsYXBzZWRdPVwiIV9oYXNNaW1pVGVtcGwgJiYgIWlzT3BlblwiIFtjbGFzcy5taW5pXT1cIl9oYXNNaW1pVGVtcGwgJiYgIWlzT3BlblwiIFtjbGFzcy5waW5uZWRdPVwicGluXCIgW2NsYXNzLnJpZ2h0XT1cInBvc2l0aW9uID09ICdyaWdodCdcIj5cbiAgICBcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiXCIgW2hpZGRlbl09XCIhaXNPcGVuICYmIF9oYXNNaW1pVGVtcGxcIj5cbiAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiLmlnLWRyYXdlci1jb250ZW50XCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICBcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiXCIgW2hpZGRlbl09XCJpc09wZW5cIj5cbiAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiLmlnLWRyYXdlci1taW5pLWNvbnRlbnRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICA8L2FzaWRlPlxuICAgICAgPGRpdiBjbGFzcz1cInN0eWxlLWR1bW15XCI+PC9kaXY+XG4gICAgYCxcbiAgICBwcm92aWRlcnM6IFtIYW1tZXJHZXN0dXJlc01hbmFnZXJdXG59KVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25EcmF3ZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgVG9nZ2xlVmlldywgT25Jbml0LCBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyAge1xuICAgIHByaXZhdGUgX2hhc01pbWlUZW1wbDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3N3aXBlQXR0YWNoZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIF93aWR0aENhY2hlOiB7d2lkdGg6IG51bWJlciwgbWluaVdpZHRoOiBudW1iZXJ9ID0ge3dpZHRoOiBudWxsLCBtaW5pV2lkdGg6IG51bGx9O1xuICAgIHByaXZhdGUgY3NzOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmc7IH0gPSB7XG4gICAgICAgIFwiZHJhd2VyXCIgOiBcImlnLW5hdi1kcmF3ZXJcIixcbiAgICAgICAgXCJvdmVybGF5XCIgOiBcImlnLW5hdi1kcmF3ZXItb3ZlcmxheVwiLFxuICAgICAgICBcIm1pbmlcIiA6IFwibWluaVwiLFxuICAgICAgICBcIm1pbmlQcm9qZWN0aW9uXCIgOiBcIi5pZy1kcmF3ZXItbWluaS1jb250ZW50XCIsXG4gICAgICAgIFwic3R5bGVEdW1teVwiIDogXCJzdHlsZS1kdW1teVwiXG4gICAgfTtcbiAgICBwcml2YXRlIF9yZXNvbHZlT3BlbjogKHZhbHVlPzogYW55IHwgUHJvbWlzZUxpa2U8YW55PikgPT4gdm9pZDtcbiAgICBwcml2YXRlIF9yZXNvbHZlQ2xvc2U6ICh2YWx1ZT86IGFueSB8IFByb21pc2VMaWtlPGFueT4pID0+IHZvaWQ7XG5cbiAgICBwcml2YXRlIF9kcmF3ZXIgOiBhbnk7XG4gICAgZ2V0IGRyYXdlcigpOiBIVE1MRWxlbWVudCB7XG4gICAgICAgIGlmICghdGhpcy5fZHJhd2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3ZXIgPSB0aGlzLmdldENoaWxkKFwiLlwiICsgdGhpcy5jc3NbXCJkcmF3ZXJcIl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kcmF3ZXI7XG4gICAgfVxuICAgIHByaXZhdGUgX292ZXJsYXk6IGFueTtcbiAgICBnZXQgb3ZlcmxheSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5KSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5ID0gdGhpcy5nZXRDaGlsZChcIi5cIiArIHRoaXMuY3NzW1wib3ZlcmxheVwiXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc3R5bGVEdW1teTogYW55O1xuICAgIGdldCBzdHlsZUR1bW15KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0eWxlRHVtbXkpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlRHVtbXkgPSB0aGlzLmdldENoaWxkKFwiLlwiICsgdGhpcy5jc3NbXCJzdHlsZUR1bW15XCJdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGVEdW1teTtcbiAgICB9XG5cbiAgICAvKiogUGFuIGFuaW1hdGlvbiBwcm9wZXJ0aWVzICovXG4gICAgcHJpdmF0ZSBfcGFubmluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3BhblN0YXJ0V2lkdGg6IG51bWJlcjtcbiAgICBwcml2YXRlIF9wYW5MaW1pdDogbnVtYmVyO1xuICAgIHByaXZhdGUgX3ByZXZpb3VzRGVsdGFYOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eSB0byBkZWNpZGUgd2hldGhlciB0byBjaGFuZ2Ugd2lkdGggb3IgdHJhbnNsYXRlIHRoZSBkcmF3ZXIgZnJvbSBwYW4gZ2VzdHVyZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGhhc0FuaW1hdGVXaWR0aCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGluIHx8IHRoaXMuX2hhc01pbWlUZW1wbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9tYXhFZGdlWm9uZTogbnVtYmVyID0gNTA7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgdG91Y2ggZ2VzdHVyZXMgKHN3aXBlIGFuZCBwYW4pLiBEZWZhdWx0cyB0byA1MCAoaW4gcHgpIGFuZCBpcyBleHRlbmRlZCB0byBhdCBsZWFzdCAxMTAlIG9mIHRoZSBtaW5pIHRlbXBsYXRlIHdpZHRoIGlmIGF2YWlsYWJsZS5cbiAgICAgKiBAcHJvdGVjdGVkIHNldCBtZXRob2RcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1heEVkZ2Vab25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4RWRnZVpvbmU7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldF9tYXhFZGdlWm9uZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX21heEVkZ2Vab25lID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBEcmF3ZXIgd2lkdGggZm9yIHNwZWNpZmljIHN0YXRlLiBXaWxsIGF0dGVtcHQgdG8gZXZhbHVhdGUgcmVxdWVzdGVkIHN0YXRlIGFuZCBjYWNoZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGV4cGVjdGVkV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEV4cGVjdGVkV2lkdGgoZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgRHJhd2VyIG1pbmkgd2lkdGggZm9yIHNwZWNpZmljIHN0YXRlLiBXaWxsIGF0dGVtcHQgdG8gZXZhbHVhdGUgcmVxdWVzdGVkIHN0YXRlIGFuZCBjYWNoZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGV4cGVjdGVkTWluaVdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFeHBlY3RlZFdpZHRoKHRydWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgdG91Y2hNYW5hZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG91Y2hNYW5hZ2VyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cG9zZXMgb3B0aW9uYWwgbmF2aWdhdGlvbiBzZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIGdldCBzdGF0ZSgpe1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuXG4gICAgLyoqIElEIG9mIHRoZSBjb21wb25lbnQgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgaWQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIG9mIHRoZSBOYXZpZ2F0aW9uIERyYXdlci4gQ2FuIGJlIFwibGVmdFwiKGRlZmF1bHQpIG9yIFwicmlnaHRcIi4gT25seSBoYXMgZWZmZWN0IHdoZW4gbm90IHBpbm5lZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgcG9zaXRpb246IHN0cmluZyA9IFwibGVmdFwiO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgdXNlIG9mIHRvdWNoIGdlc3R1cmVzIHRvIG1hbmlwdWxhdGUgdGhlIGRyYXdlciAtIHN1Y2ggYXMgc3dpcGUvcGFuIGZyb20gZWRnZSB0byBvcGVuLCBzd2lwZSB0b2dnbGUgYW5kIHBhbiBkcmFnLlxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBlbmFibGVHZXN0dXJlczogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKiogU3RhdGUgb2YgdGhlIGRyYXdlci4gKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgaXNPcGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogUGlubmVkIHN0YXRlIG9mIHRoZSBkcmF3ZXIuIEN1cnJlbnRseSBvbmx5IHN1cHBvcnQgICovXG4gICAgQElucHV0KCkgcHVibGljIHBpbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIE1pbmltdW0gZGV2aWNlIHdpZHRoIHJlcXVpcmVkIGZvciBhdXRvbWF0aWMgcGluIHRvIGJlIHRvZ2dsZWQuIERlYWZ1bHQgaXMgMTAyNCwgY2FuIGJlIHNldCB0byBmYWxzeSB2YWx1ZSB0byBpZ25vcmUuICovXG4gICAgQElucHV0KCkgcHVibGljIHBpblRocmVzaG9sZDogbnVtYmVyID0gMTAyNDtcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIHRoZSBkcmF3ZXIgaW4gaXRzIG9wZW4gc3RhdGUuIERlZmF1bHRzIHRvIDMwMHB4IGJhc2VkIG9uIHRoZSBgLmlnLW5hdi1kcmF3ZXJgIHN0eWxlLlxuICAgICAqIENhbiBiZSB1c2VkIHRvIG92ZXJyaWRlIG9yIGR5bmFtaWNhbGx5IG1vZGlmeSB0aGUgd2lkdGguXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHdpZHRoOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiB0aGUgZHJhd2VyIGluIGl0cyBtaW5pIHN0YXRlLiBEZWZhdWx0cyB0byA2MHB4IGJhc2VkIG9uIHRoZSBgLmlnLW5hdi1kcmF3ZXIubWluaWAgc3R5bGUuXG4gICAgICogQ2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgb3IgZHluYW1pY2FsbHkgbW9kaWZ5IHRoZSB3aWR0aC5cbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgbWluaVdpZHRoOiBzdHJpbmc7XG5cbiAgICAvKiogRXZlbnQgZmlyZWQgYXMgdGhlIE5hdmlnYXRpb24gRHJhd2VyIGlzIGFib3V0IHRvIG9wZW4uICovXG4gICAgQE91dHB1dCgpIG9wZW5pbmcgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgLyoqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIE5hdmlnYXRpb24gRHJhd2VyIGhhcyBvcGVuZWQuICovXG4gICAgQE91dHB1dCgpIG9wZW5lZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAvKiogRXZlbnQgZmlyZWQgYXMgdGhlIE5hdmlnYXRpb24gRHJhd2VyIGlzIGFib3V0IHRvIGNsb3NlLiAqL1xuICAgIEBPdXRwdXQoKSBjbG9zaW5nID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIC8qKiBFdmVudCBmaXJlZCB3aGVuIHRoZSBOYXZpZ2F0aW9uIERyYXdlciBoYXMgY2xvc2VkLiAqL1xuICAgIEBPdXRwdXQoKSBjbG9zZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChFbGVtZW50UmVmKSBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3N0YXRlOiBOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgLy8gcHJpdmF0ZSBhbmltYXRlOiBBbmltYXRpb25CdWlsZGVyLCBUT0RPXG4gICAgICAgIHByb3RlY3RlZCByZW5kZXJlcjpSZW5kZXJlcixcbiAgICAgICAgcHJpdmF0ZSBfdG91Y2hNYW5hZ2VyOiBIYW1tZXJHZXN0dXJlc01hbmFnZXIpXG4gICAge1xuICAgICAgICBzdXBlcihyZW5kZXJlcik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIC8vIERPTSBhbmQgQElucHV0KCktcyBpbml0aWFsaXplZFxuICAgICAgICBpZiAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLmFkZCh0aGlzLmlkLHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICAvLyB3YWl0IGZvciB0ZW1wbGF0ZSBhbmQgbmctY29udGVudCB0byBiZSByZWFkeVxuICAgICAgICB0aGlzLl9oYXNNaW1pVGVtcGwgPSB0aGlzLmdldENoaWxkKHRoaXMuY3NzW1wibWluaVByb2plY3Rpb25cIl0pICE9PSBudWxsO1xuICAgICAgICB0aGlzLnVwZGF0ZUVkZ2Vab25lKCk7XG4gICAgICAgIGlmICh0aGlzLnBpblRocmVzaG9sZCAmJiB0aGlzLmdldFdpbmRvd1dpZHRoKCkgPiB0aGlzLnBpblRocmVzaG9sZCkge1xuICAgICAgICAgICAgdGhpcy5waW4gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbmVlZCB0byBzZXQgaGVpZ2h0IHdpdGhvdXQgYWJzb2x1dGUgcG9zaXRpb25pbmdcbiAgICAgICAgdGhpcy5lbnN1cmVEcmF3ZXJIZWlnaHQoKTtcbiAgICAgICAgdGhpcy5lbnN1cmVFdmVudHMoKTtcbiAgICAgICAgLy8gVE9ETzogYXBwbHkgcGxhdGZvcm0tc2FmZSBSdWxlciBmcm9tIGh0dHA6Ly9wbG5rci5jby9lZGl0LzgxbldEeXJlWU16a3VuaWhmUmdYP3A9cHJldmlld1xuICAgICAgICAvLyAoaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvNjUxNSksIGJsb2NrZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvNjkwNFxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl90b3VjaE1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLnJlbW92ZSh0aGlzLmlkKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczoge1twcm9wTmFtZTogc3RyaW5nXTogU2ltcGxlQ2hhbmdlfSkge1xuICAgICAgICAvLyBzaW1wbGUgc2V0dGluZ3MgY2FuIGNvbWUgZnJvbSBhdHRyaWJ1dGUgc2V0IChyYXRoZXIgdGhhbiBiaW5kaW5nKSwgbWFrZSBzdXJlIGJvb2xlYW4gcHJvcHMgYXJlIGNvbnZlcnRlZFxuICAgICAgICBpZiAoY2hhbmdlc1snZW5hYmxlR2VzdHVyZXMnXSAmJiBjaGFuZ2VzWydlbmFibGVHZXN0dXJlcyddLmN1cnJlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZUdlc3R1cmVzID0gISEodGhpcy5lbmFibGVHZXN0dXJlcyAmJiB0aGlzLmVuYWJsZUdlc3R1cmVzLnRvU3RyaW5nKCkgPT09IFwidHJ1ZVwiKTtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlRXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ3BpbiddICYmIGNoYW5nZXNbJ3BpbiddLmN1cnJlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnBpbiA9ICEhKHRoaXMucGluICYmIHRoaXMucGluLnRvU3RyaW5nKCkgPT09IFwidHJ1ZVwiKTtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlRHJhd2VySGVpZ2h0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5waW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3VjaE1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZUV2ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZXNbJ3dpZHRoJ10gJiYgdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhd2VyV2lkdGgoY2hhbmdlc1snd2lkdGgnXS5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZXNbJ21pbmlXaWR0aCddKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREcmF3ZXJXaWR0aChjaGFuZ2VzWydtaW5pV2lkdGgnXS5jdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVFZGdlWm9uZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRXaW5kb3dXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuICh3aW5kb3cuaW5uZXJXaWR0aCA+IDApID8gd2luZG93LmlubmVyV2lkdGggOiBzY3JlZW4ud2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZHJhd2VyIHdpZHRoLlxuICAgICAqIEBwYXJhbSB3aWR0aCBXaWR0aCB0byBzZXQsIG11c3QgYmUgdmFsaWQgQ1NTIHNpemUgc3RyaW5nLlxuICAgICAqL1xuICAgIHByaXZhdGUgc2V0RHJhd2VyV2lkdGggKHdpZHRoOiBzdHJpbmcpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBpZih0aGlzLmRyYXdlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuZHJhd2VyLCBcIndpZHRoXCIsIHdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGVuc3VyZURyYXdlckhlaWdodCAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBpbikge1xuICAgICAgICAgICAgLy8gVE9ETzogbmVzdGVkIGluIGNvbnRlbnQ/XG4gICAgICAgICAgICAvLyBzZXRFbGVtZW50U3R5bGUgd2FybmluZyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy82NTYzXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLmRyYXdlciwgXCJoZWlnaHRcIiwgd2luZG93LmlubmVySGVpZ2h0ICsgXCJweFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgRHJhd2VyIHdpZHRoIGZvciBzcGVjaWZpYyBzdGF0ZS4gV2lsbCBhdHRlbXB0IHRvIGV2YWx1YXRlIHJlcXVlc3RlZCBzdGF0ZSBhbmQgY2FjaGUuXG4gICAgICogQHBhcmFtIG1pbmkgUmVxdWVzdCBtaW5pIHdpZHRoIGluc3RlYWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0RXhwZWN0ZWRXaWR0aCAobWluaT86IGJvb2xlYW4pIDogbnVtYmVyIHtcbiAgICAgICAgaWYgKG1pbmkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faGFzTWltaVRlbXBsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5taW5pV2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLm1pbmlXaWR0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmICghdGhpcy5pc09wZW4pIHsgLy8gVGhpcyBXT04nVCB3b3JrIGR1ZSB0byB0cmFuc2l0aW9uIHRpbWluZ3MuLi5cbiAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzFdLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dpZHRoQ2FjaGVbXCJtaW5pV2lkdGhcIl0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yY2UgY2xhc3MgZm9yIHdpZHRoIGNhbGMuIFRPRE8/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuc3R5bGVEdW1teSwgdGhpcy5jc3NbXCJkcmF3ZXJcIl0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLnN0eWxlRHVtbXksIHRoaXMuY3NzW1wibWluaVwiXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoQ2FjaGVbXCJtaW5pV2lkdGhcIl0gPSB0aGlzLnN0eWxlRHVtbXkub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuc3R5bGVEdW1teSwgdGhpcy5jc3NbXCJkcmF3ZXJcIl0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5zdHlsZUR1bW15LCB0aGlzLmNzc1tcIm1pbmlcIl0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoQ2FjaGVbXCJtaW5pV2lkdGhcIl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMud2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fd2lkdGhDYWNoZVtcIndpZHRoXCJdID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcmNlIGNsYXNzIGZvciB3aWR0aCBjYWxjLiBUT0RPP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLnN0eWxlRHVtbXksIHRoaXMuY3NzW1wiZHJhd2VyXCJdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2lkdGhDYWNoZVtcIndpZHRoXCJdID0gdGhpcy5zdHlsZUR1bW15Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLnN0eWxlRHVtbXksIHRoaXMuY3NzW1wiZHJhd2VyXCJdLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aENhY2hlW1wid2lkdGhcIl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBEcmF3ZXIgd2lkdGguXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXREcmF3ZXJXaWR0aCAoKSA6IG51bWJlciB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcmF3ZXIub2Zmc2V0V2lkdGg7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBlbnN1cmVFdmVudHMoKSB7XG4gICAgICAgIC8vIHNldCBsaXN0ZW5lcnMgZm9yIHN3aXBlL3BhbiBvbmx5IGlmIG5lZWRlZCwgYnV0IGp1c3Qgb25jZVxuICAgICAgICBpZiAodGhpcy5lbmFibGVHZXN0dXJlcyAmJiAhdGhpcy5waW4gJiYgIXRoaXMuX3N3aXBlQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIC8vIEJ1aWx0LWluIG1hbmFnZXIgaGFuZGxlcihMMjA4ODcpIGNhdXNlcyBlbmRsZXNzIGxvb3AgYW5kIG1heCBzdGFjayBleGNlcHRpb24uIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzY5OTNcbiAgICAgICAgICAgIC8vIFVzZSBvdXJzIGZvciBub3cgKHVudGlsIGJldGEuMTApOlxuICAgICAgICAgICAgLy90aGlzLnJlbmRlcmVyLmxpc3Rlbihkb2N1bWVudCwgXCJzd2lwZVwiLCB0aGlzLnN3aXBlKTtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoTWFuYWdlci5hZGRHbG9iYWxFdmVudExpc3RlbmVyKFwiZG9jdW1lbnRcIiwgXCJzd2lwZVwiLCB0aGlzLnN3aXBlKTtcbiAgICAgICAgICAgIHRoaXMuX3N3aXBlQXR0YWNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvL3RoaXMucmVuZGVyZXIubGlzdGVuKGRvY3VtZW50LCBcInBhbnN0YXJ0XCIsIHRoaXMucGFuc3RhcnQpO1xuICAgICAgICAgICAgLy90aGlzLnJlbmRlcmVyLmxpc3Rlbihkb2N1bWVudCwgXCJwYW5cIiwgdGhpcy5wYW4pO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hNYW5hZ2VyLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIoXCJkb2N1bWVudFwiLCBcInBhbnN0YXJ0XCIsIHRoaXMucGFuc3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hNYW5hZ2VyLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIoXCJkb2N1bWVudFwiLCBcInBhbm1vdmVcIiwgdGhpcy5wYW4pO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hNYW5hZ2VyLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIoXCJkb2N1bWVudFwiLCBcInBhbmVuZFwiLCB0aGlzLnBhbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUVkZ2Vab25lKCkge1xuICAgICAgICB2YXIgbWF4VmFsdWU7XG5cbiAgICAgICAgaWYgKHRoaXMuX2hhc01pbWlUZW1wbCkge1xuICAgICAgICAgICAgbWF4VmFsdWUgPSBNYXRoLm1heCh0aGlzLl9tYXhFZGdlWm9uZSwgdGhpcy5nZXRFeHBlY3RlZFdpZHRoKHRydWUpICogMS4xKTtcbiAgICAgICAgICAgIHRoaXMuc2V0X21heEVkZ2Vab25lKG1heFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3dpcGUgPSAoZXZ0OiBIYW1tZXJJbnB1dCkgPT4geyAvL3VzZSBsYW1iZGEgdG8ga2VlcCBjbGFzcyBzY29wZSAoaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODQyMzQxMC90eXBlc2NyaXB0LXJldGFpbi1zY29wZS1pbi1ldmVudC1saXN0ZW5lcilcbiAgICAgICAgLy8gVE9ETzogQ291bGQgYWxzbyBmb3JjZSBpbnB1dCB0eXBlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNzEwODA1MlxuICAgICAgICBpZighdGhpcy5lbmFibGVHZXN0dXJlcyB8fCBldnQucG9pbnRlclR5cGUgIT09IFwidG91Y2hcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFtbWVySlMgc3dpcGUgaXMgaG9yaXpvbnRhbC1vbmx5IGJ5IGRlZmF1bHQsIGRvbid0IGNoZWNrIGRlbHRhWVxuICAgICAgICB2YXIgZGVsdGFYLCBzdGFydFBvc2l0aW9uO1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICAvLyB3aGVuIG9uIHRoZSByaWdodCB1c2UgaW52ZXJzZSBvZiBkZWx0YVhcbiAgICAgICAgICAgIGRlbHRhWCA9IC1ldnQuZGVsdGFYO1xuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IHRoaXMuZ2V0V2luZG93V2lkdGgoKSAtIChldnQuY2VudGVyLnggKyBldnQuZGlzdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsdGFYID0gZXZ0LmRlbHRhWDtcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSBldnQuY2VudGVyLnggLSBldnQuZGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgLy9vbmx5IGFjY2VwdCBjbG9zaW5nIHN3aXBlIChpZ25vcmluZyBtaW5FZGdlWm9uZSkgd2hlbiB0aGUgZHJhd2VyIGlzIGV4cGFuZGVkOlxuICAgICAgICBpZiAoKHRoaXMuaXNPcGVuICYmIGRlbHRhWCA8IDApIHx8XG4gICAgICAgICAgICAvLyBwb3NpdGl2ZSBkZWx0YVggZnJvbSB0aGUgZWRnZTpcbiAgICAgICAgICAgIChkZWx0YVggPiAwICYmIHN0YXJ0UG9zaXRpb24gPCB0aGlzLm1heEVkZ2Vab25lKSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHBhbnN0YXJ0ID0gKGV2dDogSGFtbWVySW5wdXQpID0+IHsgLy8gVE9ETzogdGVzdCBjb2RlXG4gICAgICAgIGlmKCF0aGlzLmVuYWJsZUdlc3R1cmVzIHx8IHRoaXMucGluIHx8IGV2dC5wb2ludGVyVHlwZSAhPT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uID09PSBcInJpZ2h0XCIgPyB0aGlzLmdldFdpbmRvd1dpZHRoKCkgLSAoZXZ0LmNlbnRlci54ICsgZXZ0LmRpc3RhbmNlKSA6IGV2dC5jZW50ZXIueCAtIGV2dC5kaXN0YW5jZTtcblxuICAgICAgICAvLyBjYWNoZSB3aWR0aCBkdXJpbmcgYW5pbWF0aW9uLCBmbGFnIHRvIGFsbG93IGZ1cnRoZXIgaGFuZGxpbmdcbiAgICAgICAgaWYodGhpcy5pc09wZW4gfHwgKHN0YXJ0UG9zaXRpb24gPCB0aGlzLm1heEVkZ2Vab25lKSkge1xuICAgICAgICAgICAgdGhpcy5fcGFubmluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9wYW5TdGFydFdpZHRoID0gIHRoaXMuZ2V0RXhwZWN0ZWRXaWR0aCghdGhpcy5pc09wZW4pO1xuICAgICAgICAgICAgdGhpcy5fcGFuTGltaXQgPSB0aGlzLmdldEV4cGVjdGVkV2lkdGgodGhpcy5pc09wZW4pO1xuXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLm92ZXJsYXksIFwicGFubmluZ1wiLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuZHJhd2VyLCBcInBhbm5pbmdcIiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHBhbiA9IChldnQ6IEhhbW1lcklucHV0KSA9PiB7XG4gICAgICAgIC8vIFRPRE86IGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpOyBnZXQgYWN0dWFsIGRlbHRhIChub3QgdG90YWwgc2Vzc2lvbiBvbmUpIGZyb20gZXZlbnQ/XG4gICAgICAgIC8vIHBhbiBXSUxMIGFsc28gZmlyZSBhZnRlciBhIGZ1bGwgc3dpcGUsIG9ubHkgcmVzaXplIG9uIGZsYWdcbiAgICAgICAgaWYgKCF0aGlzLl9wYW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJpZ2h0OiBib29sZWFuID0gdGhpcy5wb3NpdGlvbiA9PT0gXCJyaWdodFwiLFxuICAgICAgICAgICAgLy8gd2hlbiBvbiB0aGUgcmlnaHQgdXNlIGludmVyc2Ugb2YgZGVsdGFYXG4gICAgICAgICAgICBkZWx0YVggPSByaWdodCA/IC1ldnQuZGVsdGFYIDogZXZ0LmRlbHRhWCxcbiAgICAgICAgICAgIHZpc2libGVXaWR0aCwgbmV3WCxcbiAgICAgICAgICAgIHBlcmNlbnQ7XG5cbiAgICAgICAgdmlzaWJsZVdpZHRoID0gdGhpcy5fcGFuU3RhcnRXaWR0aCArIGRlbHRhWDtcblxuXG4gICAgICAgIGlmKHRoaXMuaXNPcGVuICYmIGRlbHRhWCA8IDApIHtcbiAgICAgICAgICAgIC8vIHdoZW4gdmlzaWJsZVdpZHRoIGhpdHMgbGltaXQgLSBzdG9wIGFuaW1hdGluZ1xuICAgICAgICAgICAgaWYgKHZpc2libGVXaWR0aCA8PSB0aGlzLl9wYW5MaW1pdCkgIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQW5pbWF0ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9ICh2aXNpYmxlV2lkdGggLSB0aGlzLl9wYW5MaW1pdCkgLyAodGhpcy5fcGFuU3RhcnRXaWR0aCAtIHRoaXMuX3BhbkxpbWl0KTtcbiAgICAgICAgICAgICAgICBuZXdYID0gdmlzaWJsZVdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gdmlzaWJsZVdpZHRoIC8gdGhpcy5fcGFuU3RhcnRXaWR0aDtcbiAgICAgICAgICAgICAgICBuZXdYID0gZXZ0LmRlbHRhWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0WFNpemUobmV3WCwgcGVyY2VudC50b1ByZWNpc2lvbigyKSk7XG5cbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc09wZW4gJiYgZGVsdGFYID4gMCl7XG4gICAgICAgICAgICAvLyB3aGVuIHZpc2libGVXaWR0aCBoaXRzIGxpbWl0IC0gc3RvcCBhbmltYXRpbmdcbiAgICAgICAgICAgIGlmICh2aXNpYmxlV2lkdGggPj0gdGhpcy5fcGFuTGltaXQpIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQW5pbWF0ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAodmlzaWJsZVdpZHRoIC0gdGhpcy5fcGFuU3RhcnRXaWR0aCkgLyAodGhpcy5fcGFuTGltaXQgLSB0aGlzLl9wYW5TdGFydFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgbmV3WCA9IHZpc2libGVXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9IHZpc2libGVXaWR0aCAvIHRoaXMuX3BhbkxpbWl0O1xuICAgICAgICAgICAgICAgIG5ld1ggPSAodGhpcy5fcGFuTGltaXQgLSB2aXNpYmxlV2lkdGgpICogKHJpZ2h0ID8gMSA6IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0WFNpemUobmV3WCwgcGVyY2VudC50b1ByZWNpc2lvbigyKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHBhbkVuZCA9IChldnQ6IEhhbW1lcklucHV0KSA9PiB7XG4gICAgICAgIGlmKHRoaXMuX3Bhbm5pbmcpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YVggPSB0aGlzLnBvc2l0aW9uID09PSBcInJpZ2h0XCIgPyAtZXZ0LmRlbHRhWCA6IGV2dC5kZWx0YVgsXG4gICAgICAgICAgICAgICAgdmlzaWJsZVdpZHRoOiBudW1iZXIgPSB0aGlzLl9wYW5TdGFydFdpZHRoICsgZGVsdGFYO1xuICAgICAgICAgICAgdGhpcy5yZXNldFBhbigpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBwYW4gYnJvdWdodCB0aGUgZHJhd2VyIHRvIDUwJVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuICYmIHZpc2libGVXaWR0aCA8PSB0aGlzLl9wYW5TdGFydFdpZHRoLzIgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSh0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNPcGVuICYmIHZpc2libGVXaWR0aCA+PSB0aGlzLl9wYW5MaW1pdC8yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGFuU3RhcnRXaWR0aCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHJlc2V0UGFuKCkge1xuICAgICAgICB0aGlzLl9wYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIC8qIHN0eWxlcyBmYWlsIHRvIGFwcGx5IHdoZW4gc2V0IG9uIHBhcmVudCBkdWUgdG8gZXh0cmEgYXR0cmlidXRlcywgcHJvYiBuZyBidWcgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5vdmVybGF5LCBcInBhbm5pbmdcIiwgZmFsc2UpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLmRyYXdlciwgXCJwYW5uaW5nXCIsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zZXRYU2l6ZSgwLCBcIlwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvciB3aWR0aCBpbiBjYXNlIHRoZSBkcmF3ZXIgZG9lc24ndCBjaGFuZ2UgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHggdGhlIG51bWJlciBwaXhlbHMgdG8gdHJhbnNsYXRlIG9uIHRoZSBYIGF4aXMgb3IgdGhlIHdpZHRoIHRvIHNldC4gMCB3aWR0aCB3aWxsIGNsZWFyIHRoZSBzdHlsZSBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSBvcGFjaXR5IG9wdGlvbmFsIHZhbHVlIHRvIGFwcGx5IHRvIHRoZSBvdmVybGF5XG4gICAgICovXG4gICAgcHJpdmF0ZSBzZXRYU2l6ZSAoeDogbnVtYmVyLCBvcGFjaXR5Pzogc3RyaW5nKSB7XG4gICAgICAgIC8vIEFuZ3VsYXIgcG9seWZpbGxzIHBhdGNoZXMgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSwgYnV0IHN3aXRjaCB0byBEb21BZGFwdGVyIEFQSSAoVE9ETylcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNBbmltYXRlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLmRyYXdlciwgXCJ3aWR0aFwiLCB4ID8gTWF0aC5hYnMoeCkgKyBcInB4XCIgOiBcIlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5kcmF3ZXIsIFwidHJhbnNmb3JtXCIsIHggPyBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwicHgsMCwwKVwiIDogXCJcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5kcmF3ZXIsIFwiLXdlYmtpdC10cmFuc2Zvcm1cIiwgIHggPyBcInRyYW5zbGF0ZTNkKFwiICt4ICsgXCJweCwwLDApXCIgOiBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLm92ZXJsYXksIFwib3BhY2l0eVwiLCBvcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSBvcGVuIHN0YXRlIG9mIHRoZSBOYXZpZ2F0aW9uIERyYXdlci5cbiAgICAgKiBAcGFyYW0gZmlyZUV2ZW50cyBPcHRpb25hbCBmbGFnIGRldGVybWluaW5nIHdoZXRoZXIgZXZlbnRzIHNob3VsZCBiZSBmaXJlZCBvciBub3QuXG4gICAgICogQHJldHVybiBQcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgdG9nZ2xlKGZpcmVFdmVudHM/OiBib29sZWFuKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZShmaXJlRXZlbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZW4oZmlyZUV2ZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBOYXZpZ2F0aW9uIERyYXdlci4gSGFzIG5vIGVmZmVjdCBpZiBhbHJlYWR5IG9wZW5lZC5cbiAgICAgKiBAcGFyYW0gZmlyZUV2ZW50cyBPcHRpb25hbCBmbGFnIGRldGVybWluaW5nIHdoZXRoZXIgZXZlbnRzIHNob3VsZCBiZSBmaXJlZCBvciBub3QuXG4gICAgICogQHJldHVybiBQcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgb3BlbihmaXJlRXZlbnRzPzogYm9vbGVhbik6IFByb21pc2U8YW55PiB7XG4gICAgICAgIGlmICh0aGlzLl9wYW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0UGFuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICBpZiAoZmlyZUV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5vcGVuaW5nLmVtaXQoXCJvcGVuaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcblxuICAgICAgIC8vIFRPRE86IFN3aXRjaCB0byBhbmltYXRlIEFQSSB3aGVuIGF2YWlsYWJsZVxuICAgICAgICAvLyB2YXIgYW5pbWF0aW9uQ3NzID0gdGhpcy5hbmltYXRlLmNzcygpO1xuICAgICAgICAvLyAgICAgYW5pbWF0aW9uQ3NzXG4gICAgICAgIC8vICAgICAgICAgLnNldFN0eWxlcyh7J3dpZHRoJzonNTBweCd9LCB7J3dpZHRoJzonNDAwcHgnfSlcbiAgICAgICAgLy8gICAgICAgICAuc3RhcnQodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpXG4gICAgICAgIC8vICAgICAgICAgLm9uQ29tcGxldGUoKCkgPT4gYW5pbWF0aW9uQ3NzLnNldFRvU3R5bGVzKHsnd2lkdGgnOidhdXRvJ30pLnN0YXJ0KHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgdGhpcy50b2dnbGVPcGVuZWRFdmVudCwgZmFsc2UpO1xuICAgICAgICB0aGlzLnNldERyYXdlcldpZHRoKHRoaXMud2lkdGgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxhbnk+KCByZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVPcGVuID0gKHZhbHVlPzogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcmVFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuZWQuZW1pdChcIm9wZW5lZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9ICk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0b2dnbGVPcGVuZWRFdmVudCA9IChldnQ/KSA9PiB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIHRoaXMudG9nZ2xlT3BlbmVkRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZU9wZW4oXCJvcGVuZWRcIik7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9yZXNvbHZlQ2xvc2U7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0b2dnbGVDbG9zZWRFdmVudCA9IChldnQ/KSA9PiB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIHRoaXMudG9nZ2xlQ2xvc2VkRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUNsb3NlKFwiY2xvc2VkXCIpO1xuICAgICAgICBkZWxldGUgdGhpcy5fcmVzb2x2ZUNsb3NlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIE5hdmlnYXRpb24gRHJhd2VyLiBIYXMgbm8gZWZmZWN0IGlmIGFscmVhZHkgY2xvc2VkLlxuICAgICAqIEBwYXJhbSBmaXJlRXZlbnRzIE9wdGlvbmFsIGZsYWcgZGV0ZXJtaW5pbmcgd2hldGhlciBldmVudHMgc2hvdWxkIGJlIGZpcmVkIG9yIG5vdC5cbiAgICAgKiBAcmV0dXJuIFByb21pc2UgdGhhdCBpcyByZXNvbHZlZCBvbmNlIHRoZSBvcGVyYXRpb24gY29tcGxldGVzLlxuICAgICAqL1xuICAgIHB1YmxpYyBjbG9zZShmaXJlRXZlbnRzPzogYm9vbGVhbik6IFByb21pc2U8YW55PiB7XG4gICAgICAgIGlmICh0aGlzLl9wYW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0UGFuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJlRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NpbmcuZW1pdChcImNsb3NpbmdcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNldERyYXdlcldpZHRoKHRoaXMuX2hhc01pbWlUZW1wbCA/IHRoaXMubWluaVdpZHRoIDogXCJcIik7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIHRoaXMudG9nZ2xlQ2xvc2VkRXZlbnQsIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8YW55PiggcmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlQ2xvc2UgPSAodmFsdWU/OiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyZUV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlZC5lbWl0KFwiY2xvc2VkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gKTtcbiAgICB9XG59XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtOYXZpZ2F0aW9uRHJhd2VyXSxcbiAgICBleHBvcnRzOiBbTmF2aWdhdGlvbkRyYXdlcl1cbn0pXG5leHBvcnQgY2xhc3MgTmF2aWdhdGlvbkRyYXdlck1vZHVsZSB7XG59XG4iXX0=
