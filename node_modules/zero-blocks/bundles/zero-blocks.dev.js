System.registerDynamic("zero-blocks/core/base", [], true, function ($__require, exports, module) {
    "use strict";
    // TODO: Consider measuring util with Ruler https://github.com/angular/angular/issues/6515
    /**
     * Base component class
     */

    var define,
        global = this || self,
        GLOBAL = global;
    var BaseComponent = function () {
        function BaseComponent(renderer) {
            this.renderer = renderer;
        }
        /**
         * Get child element by selector.
         * Replacement for `elementRef.nativeElement.querySelector`
         * @returns Returns the matched DOM element or null
         */
        BaseComponent.prototype.getChild = function (selector) {
            // With DomRenderer selectRootElement will use querySelector against document (!!!) Also will throw if not found
            try {
                if (this.id) {
                    selector = "#" + this.id + " " + selector;
                }
                // WARNING: selectRootElement will for whatever reason call clear as well..wiping all contents!
                // -----
                // return this.renderer.selectRootElement(selector);
                // ------
                // INSTEAD temporary per http://stackoverflow.com/a/34433626
                // return DOM.querySelector(DOM.query("document"), selector);
                // could also try http://blog.mgechev.com/2016/01/23/angular2-viewchildren-contentchildren-difference-viewproviders#comment-2543997382
                return document.querySelector(selector);
            } catch (error) {
                return null;
            }
        };
        return BaseComponent;
    }();
    exports.BaseComponent = BaseComponent;
    return module.exports;
});
System.registerDynamic("zero-blocks/core/navigation/nav-service", [], true, function ($__require, exports, module) {
    "use strict";
    /**
     * Common service to be injected between components where those implementing common
     * ToggleView interface can register and toggle directives can call their methods.
     * TODO: Track currently active? Events?
     */

    var define,
        global = this || self,
        GLOBAL = global;
    var NavigationService = function () {
        function NavigationService() {
            this.navs = {};
        }
        NavigationService.prototype.add = function (id, navItem) {
            this.navs[id] = navItem;
        };
        NavigationService.prototype.remove = function (id) {
            delete this.navs[id];
        };
        NavigationService.prototype.get = function (id) {
            if (id) {
                return this.navs[id];
            }
        };
        NavigationService.prototype.toggle = function (id, fireEvents) {
            if (this.navs[id]) {
                return this.navs[id].toggle(fireEvents);
            } else {
                return Promise.reject("No ToggleView component found for id:" + id);
            }
        };
        NavigationService.prototype.open = function (id, fireEvents) {
            if (this.navs[id]) {
                return this.navs[id].open(fireEvents);
            } else {
                return Promise.reject("No ToggleView component found for id:" + id);
            }
        };
        NavigationService.prototype.close = function (id, fireEvents) {
            if (this.navs[id]) {
                return this.navs[id].close(fireEvents);
            } else {
                return Promise.reject("No ToggleView component found for id:" + id);
            }
        };
        return NavigationService;
    }();
    exports.NavigationService = NavigationService;
    return module.exports;
});
System.registerDynamic("zero-blocks/core/navigation/directives", ["@angular/core", "./nav-service"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var nav_service_1 = $__require("./nav-service");
    // TODO: (style) NavToggleDirective, igNavToggle selector ?
    var NavigationToggle = function () {
        function NavigationToggle(nav) {
            this.state = nav;
        }
        NavigationToggle.prototype.toggleNavigationDrawer = function () {
            this.state.toggle(this.target, true);
        };
        __decorate([core_1.Input("ig-nav-toggle"), __metadata('design:type', Object)], NavigationToggle.prototype, "target", void 0);
        __decorate([core_1.HostListener('click'), __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], NavigationToggle.prototype, "toggleNavigationDrawer", null);
        NavigationToggle = __decorate([core_1.Directive({ selector: '[ig-nav-toggle]' }), __metadata('design:paramtypes', [nav_service_1.NavigationService])], NavigationToggle);
        return NavigationToggle;
    }();
    exports.NavigationToggle = NavigationToggle;
    // TODO: (style) NavCloseDirective, igNavClose selector ?
    var NavigationClose = function () {
        function NavigationClose(nav) {
            this.state = nav;
        }
        NavigationClose.prototype.closeNavigationDrawer = function () {
            this.state.close(this.target, true);
        };
        __decorate([core_1.Input("ig-nav-close"), __metadata('design:type', Object)], NavigationClose.prototype, "target", void 0);
        __decorate([core_1.HostListener('click'), __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], NavigationClose.prototype, "closeNavigationDrawer", null);
        NavigationClose = __decorate([core_1.Directive({ selector: '[ig-nav-close]' }), __metadata('design:paramtypes', [nav_service_1.NavigationService])], NavigationClose);
        return NavigationClose;
    }();
    exports.NavigationClose = NavigationClose;
    return module.exports;
});
System.registerDynamic('zero-blocks/core/navigation', ['./navigation/nav-service', './navigation/directives'], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    __export($__require('./navigation/nav-service'));
    __export($__require('./navigation/directives'));
    return module.exports;
});
System.registerDynamic("zero-blocks/navigation-drawer/navigation-drawer", ["@angular/core", "../core/base", "../core/touch", "../core/navigation"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __param = this && this.__param || function (paramIndex, decorator) {
        return function (target, key) {
            decorator(target, key, paramIndex);
        };
    };
    var core_1 = $__require("@angular/core");
    // import {AnimationBuilder} from 'angular2/src/animate/animation_builder'; TODO
    var base_1 = $__require("../core/base");
    var touch_1 = $__require("../core/touch");
    var navigation_1 = $__require("../core/navigation");
    /**
     * Navigation Drawer component supports collapsible side navigation container.
     * Usage:
     * ```
     * <ig-nav-drawer id="ID" (event output bindings) [input bindings]>
     *  <div class="ig-drawer-content">
     *   <!-- expanded template -->
     *  </div>
     * </ig-nav-drawer>
     * ```
     * Can also include an optional `<div class="ig-drawer-mini-content">`.
     * ID required to register with NavigationService allow directives to target the control.
     */
    var NavigationDrawer = function (_super) {
        __extends(NavigationDrawer, _super);
        function NavigationDrawer(elementRef, _state,
        // private animate: AnimationBuilder, TODO
        renderer, _touchManager) {
            var _this = this;
            _super.call(this, renderer);
            this.elementRef = elementRef;
            this._state = _state;
            this.renderer = renderer;
            this._touchManager = _touchManager;
            this._hasMimiTempl = false;
            this._swipeAttached = false;
            this._widthCache = { width: null, miniWidth: null };
            this.css = {
                "drawer": "ig-nav-drawer",
                "overlay": "ig-nav-drawer-overlay",
                "mini": "mini",
                "miniProjection": ".ig-drawer-mini-content",
                "styleDummy": "style-dummy"
            };
            /** Pan animation properties */
            this._panning = false;
            this._maxEdgeZone = 50;
            /**
             * Position of the Navigation Drawer. Can be "left"(default) or "right". Only has effect when not pinned.
             */
            this.position = "left";
            /**
             * Enables the use of touch gestures to manipulate the drawer - such as swipe/pan from edge to open, swipe toggle and pan drag.
             */
            this.enableGestures = true;
            /** State of the drawer. */
            this.isOpen = false;
            /** Pinned state of the drawer. Currently only support  */
            this.pin = false;
            /** Minimum device width required for automatic pin to be toggled. Deafult is 1024, can be set to falsy value to ignore. */
            this.pinThreshold = 1024;
            /** Event fired as the Navigation Drawer is about to open. */
            this.opening = new core_1.EventEmitter();
            /** Event fired when the Navigation Drawer has opened. */
            this.opened = new core_1.EventEmitter();
            /** Event fired as the Navigation Drawer is about to close. */
            this.closing = new core_1.EventEmitter();
            /** Event fired when the Navigation Drawer has closed. */
            this.closed = new core_1.EventEmitter();
            this.swipe = function (evt) {
                // TODO: Could also force input type: http://stackoverflow.com/a/27108052
                if (!_this.enableGestures || evt.pointerType !== "touch") {
                    return;
                }
                // HammerJS swipe is horizontal-only by default, don't check deltaY
                var deltaX, startPosition;
                if (_this.position === "right") {
                    // when on the right use inverse of deltaX
                    deltaX = -evt.deltaX;
                    startPosition = _this.getWindowWidth() - (evt.center.x + evt.distance);
                } else {
                    deltaX = evt.deltaX;
                    startPosition = evt.center.x - evt.distance;
                }
                //only accept closing swipe (ignoring minEdgeZone) when the drawer is expanded:
                if (_this.isOpen && deltaX < 0 ||
                // positive deltaX from the edge:
                deltaX > 0 && startPosition < _this.maxEdgeZone) {
                    _this.toggle(true);
                }
            };
            this.panstart = function (evt) {
                if (!_this.enableGestures || _this.pin || evt.pointerType !== "touch") {
                    return;
                }
                var startPosition = _this.position === "right" ? _this.getWindowWidth() - (evt.center.x + evt.distance) : evt.center.x - evt.distance;
                // cache width during animation, flag to allow further handling
                if (_this.isOpen || startPosition < _this.maxEdgeZone) {
                    _this._panning = true;
                    _this._panStartWidth = _this.getExpectedWidth(!_this.isOpen);
                    _this._panLimit = _this.getExpectedWidth(_this.isOpen);
                    _this.renderer.setElementClass(_this.overlay, "panning", true);
                    _this.renderer.setElementClass(_this.drawer, "panning", true);
                }
            };
            this.pan = function (evt) {
                // TODO: input.deltaX = prevDelta.x + (center.x - offset.x); get actual delta (not total session one) from event?
                // pan WILL also fire after a full swipe, only resize on flag
                if (!_this._panning) {
                    return;
                }
                var right = _this.position === "right",

                // when on the right use inverse of deltaX
                deltaX = right ? -evt.deltaX : evt.deltaX,
                    visibleWidth,
                    newX,
                    percent;
                visibleWidth = _this._panStartWidth + deltaX;
                if (_this.isOpen && deltaX < 0) {
                    // when visibleWidth hits limit - stop animating
                    if (visibleWidth <= _this._panLimit) return;
                    if (_this.hasAnimateWidth) {
                        percent = (visibleWidth - _this._panLimit) / (_this._panStartWidth - _this._panLimit);
                        newX = visibleWidth;
                    } else {
                        percent = visibleWidth / _this._panStartWidth;
                        newX = evt.deltaX;
                    }
                    _this.setXSize(newX, percent.toPrecision(2));
                } else if (!_this.isOpen && deltaX > 0) {
                    // when visibleWidth hits limit - stop animating
                    if (visibleWidth >= _this._panLimit) return;
                    if (_this.hasAnimateWidth) {
                        percent = (visibleWidth - _this._panStartWidth) / (_this._panLimit - _this._panStartWidth);
                        newX = visibleWidth;
                    } else {
                        percent = visibleWidth / _this._panLimit;
                        newX = (_this._panLimit - visibleWidth) * (right ? 1 : -1);
                    }
                    _this.setXSize(newX, percent.toPrecision(2));
                }
            };
            this.panEnd = function (evt) {
                if (_this._panning) {
                    var deltaX = _this.position === "right" ? -evt.deltaX : evt.deltaX,
                        visibleWidth = _this._panStartWidth + deltaX;
                    _this.resetPan();
                    // check if pan brought the drawer to 50%
                    if (_this.isOpen && visibleWidth <= _this._panStartWidth / 2) {
                        _this.close(true);
                    } else if (!_this.isOpen && visibleWidth >= _this._panLimit / 2) {
                        _this.open(true);
                    }
                    _this._panStartWidth = null;
                }
            };
            this.toggleOpenedEvent = function (evt) {
                _this.elementRef.nativeElement.removeEventListener("transitionend", _this.toggleOpenedEvent, false);
                _this._resolveOpen("opened");
                delete _this._resolveClose;
            };
            this.toggleClosedEvent = function (evt) {
                _this.elementRef.nativeElement.removeEventListener("transitionend", _this.toggleClosedEvent, false);
                _this._resolveClose("closed");
                delete _this._resolveClose;
            };
        }
        Object.defineProperty(NavigationDrawer.prototype, "drawer", {
            get: function () {
                if (!this._drawer) {
                    this._drawer = this.getChild("." + this.css["drawer"]);
                }
                return this._drawer;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationDrawer.prototype, "overlay", {
            get: function () {
                if (!this._overlay) {
                    this._overlay = this.getChild("." + this.css["overlay"]);
                }
                return this._overlay;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationDrawer.prototype, "styleDummy", {
            get: function () {
                if (!this._styleDummy) {
                    this._styleDummy = this.getChild("." + this.css["styleDummy"]);
                }
                return this._styleDummy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationDrawer.prototype, "hasAnimateWidth", {
            /**
             * Property to decide whether to change width or translate the drawer from pan gesture.
             */
            get: function () {
                return this.pin || this._hasMimiTempl;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationDrawer.prototype, "maxEdgeZone", {
            /**
             * Used for touch gestures (swipe and pan). Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
             * @protected set method
             */
            get: function () {
                return this._maxEdgeZone;
            },
            enumerable: true,
            configurable: true
        });
        NavigationDrawer.prototype.set_maxEdgeZone = function (value) {
            this._maxEdgeZone = value;
        };
        Object.defineProperty(NavigationDrawer.prototype, "expectedWidth", {
            /**
             * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
             */
            get: function () {
                return this.getExpectedWidth(false);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationDrawer.prototype, "expectedMiniWidth", {
            /**
             * Get the Drawer mini width for specific state. Will attempt to evaluate requested state and cache.
             */
            get: function () {
                return this.getExpectedWidth(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationDrawer.prototype, "touchManager", {
            get: function () {
                return this._touchManager;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationDrawer.prototype, "state", {
            /**
             * Exposes optional navigation service
             */
            get: function () {
                return this._state;
            },
            enumerable: true,
            configurable: true
        });
        NavigationDrawer.prototype.ngOnInit = function () {
            // DOM and @Input()-s initialized
            if (this._state) {
                this._state.add(this.id, this);
            }
        };
        NavigationDrawer.prototype.ngAfterContentInit = function () {
            // wait for template and ng-content to be ready
            this._hasMimiTempl = this.getChild(this.css["miniProjection"]) !== null;
            this.updateEdgeZone();
            if (this.pinThreshold && this.getWindowWidth() > this.pinThreshold) {
                this.pin = true;
            }
            // need to set height without absolute positioning
            this.ensureDrawerHeight();
            this.ensureEvents();
            // TODO: apply platform-safe Ruler from http://plnkr.co/edit/81nWDyreYMzkunihfRgX?p=preview
            // (https://github.com/angular/angular/issues/6515), blocked by https://github.com/angular/angular/issues/6904
        };
        NavigationDrawer.prototype.ngOnDestroy = function () {
            this._touchManager.destroy();
            if (this._state) {
                this._state.remove(this.id);
            }
        };
        NavigationDrawer.prototype.ngOnChanges = function (changes) {
            // simple settings can come from attribute set (rather than binding), make sure boolean props are converted
            if (changes['enableGestures'] && changes['enableGestures'].currentValue !== undefined) {
                this.enableGestures = !!(this.enableGestures && this.enableGestures.toString() === "true");
                this.ensureEvents();
            }
            if (changes['pin'] && changes['pin'].currentValue !== undefined) {
                this.pin = !!(this.pin && this.pin.toString() === "true");
                this.ensureDrawerHeight();
                if (this.pin) {
                    this._touchManager.destroy();
                } else {
                    this.ensureEvents();
                }
            }
            if (changes['width'] && this.isOpen) {
                this.setDrawerWidth(changes['width'].currentValue);
            }
            if (changes['miniWidth']) {
                if (!this.isOpen) {
                    this.setDrawerWidth(changes['miniWidth'].currentValue);
                }
                this.updateEdgeZone();
            }
        };
        NavigationDrawer.prototype.getWindowWidth = function () {
            return window.innerWidth > 0 ? window.innerWidth : screen.width;
        };
        /**
         * Sets the drawer width.
         * @param width Width to set, must be valid CSS size string.
         */
        NavigationDrawer.prototype.setDrawerWidth = function (width) {
            var _this = this;
            window.requestAnimationFrame(function () {
                if (_this.drawer) {
                    _this.renderer.setElementStyle(_this.drawer, "width", width);
                }
            });
        };
        NavigationDrawer.prototype.ensureDrawerHeight = function () {
            if (this.pin) {
                // TODO: nested in content?
                // setElementStyle warning https://github.com/angular/angular/issues/6563
                this.renderer.setElementStyle(this.drawer, "height", window.innerHeight + "px");
            }
        };
        /**
         * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
         * @param mini Request mini width instead
         */
        NavigationDrawer.prototype.getExpectedWidth = function (mini) {
            if (mini) {
                if (!this._hasMimiTempl) {
                    return 0;
                }
                if (this.miniWidth) {
                    return parseFloat(this.miniWidth);
                } else {
                    // if (!this.isOpen) { // This WON'T work due to transition timings...
                    //     return this.elementRef.nativeElement.children[1].offsetWidth;
                    // } else {
                    if (this._widthCache["miniWidth"] === null) {
                        // force class for width calc. TODO?
                        this.renderer.setElementClass(this.styleDummy, this.css["drawer"], true);
                        this.renderer.setElementClass(this.styleDummy, this.css["mini"], true);
                        this._widthCache["miniWidth"] = this.styleDummy.offsetWidth;
                        this.renderer.setElementClass(this.styleDummy, this.css["drawer"], false);
                        this.renderer.setElementClass(this.styleDummy, this.css["mini"], false);
                    }
                    return this._widthCache["miniWidth"];
                }
            } else {
                if (this.width) {
                    return parseFloat(this.width);
                } else {
                    if (this._widthCache["width"] === null) {
                        // force class for width calc. TODO?
                        this.renderer.setElementClass(this.styleDummy, this.css["drawer"], true);
                        this._widthCache["width"] = this.styleDummy.offsetWidth;
                        this.renderer.setElementClass(this.styleDummy, this.css["drawer"], false);
                    }
                    return this._widthCache["width"];
                }
            }
        };
        /**
         * Get current Drawer width.
         */
        NavigationDrawer.prototype.getDrawerWidth = function () {
            return this.drawer.offsetWidth;
        };
        NavigationDrawer.prototype.ensureEvents = function () {
            // set listeners for swipe/pan only if needed, but just once
            if (this.enableGestures && !this.pin && !this._swipeAttached) {
                // Built-in manager handler(L20887) causes endless loop and max stack exception. https://github.com/angular/angular/issues/6993
                // Use ours for now (until beta.10):
                //this.renderer.listen(document, "swipe", this.swipe);
                this._touchManager.addGlobalEventListener("document", "swipe", this.swipe);
                this._swipeAttached = true;
                //this.renderer.listen(document, "panstart", this.panstart);
                //this.renderer.listen(document, "pan", this.pan);
                this._touchManager.addGlobalEventListener("document", "panstart", this.panstart);
                this._touchManager.addGlobalEventListener("document", "panmove", this.pan);
                this._touchManager.addGlobalEventListener("document", "panend", this.panEnd);
            }
        };
        NavigationDrawer.prototype.updateEdgeZone = function () {
            var maxValue;
            if (this._hasMimiTempl) {
                maxValue = Math.max(this._maxEdgeZone, this.getExpectedWidth(true) * 1.1);
                this.set_maxEdgeZone(maxValue);
            }
        };
        NavigationDrawer.prototype.resetPan = function () {
            this._panning = false;
            /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
            this.renderer.setElementClass(this.overlay, "panning", false);
            this.renderer.setElementClass(this.drawer, "panning", false);
            this.setXSize(0, "");
        };
        /**
         * Sets the absolute position or width in case the drawer doesn't change position.
         * @param x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
         * @param opacity optional value to apply to the overlay
         */
        NavigationDrawer.prototype.setXSize = function (x, opacity) {
            var _this = this;
            // Angular polyfills patches window.requestAnimationFrame, but switch to DomAdapter API (TODO)
            window.requestAnimationFrame(function () {
                if (_this.hasAnimateWidth) {
                    _this.renderer.setElementStyle(_this.drawer, "width", x ? Math.abs(x) + "px" : "");
                } else {
                    _this.renderer.setElementStyle(_this.drawer, "transform", x ? "translate3d(" + x + "px,0,0)" : "");
                    _this.renderer.setElementStyle(_this.drawer, "-webkit-transform", x ? "translate3d(" + x + "px,0,0)" : "");
                }
                if (opacity !== undefined) {
                    _this.renderer.setElementStyle(_this.overlay, "opacity", opacity);
                }
            });
        };
        /**
         * Toggle the open state of the Navigation Drawer.
         * @param fireEvents Optional flag determining whether events should be fired or not.
         * @return Promise that is resolved once the operation completes.
         */
        NavigationDrawer.prototype.toggle = function (fireEvents) {
            if (this.isOpen) {
                return this.close(fireEvents);
            } else {
                return this.open(fireEvents);
            }
        };
        /**
         * Open the Navigation Drawer. Has no effect if already opened.
         * @param fireEvents Optional flag determining whether events should be fired or not.
         * @return Promise that is resolved once the operation completes.
         */
        NavigationDrawer.prototype.open = function (fireEvents) {
            var _this = this;
            if (this._panning) {
                this.resetPan();
            }
            if (this.isOpen) {
                return Promise.resolve();
            }
            if (fireEvents) {
                this.opening.emit("opening");
            }
            this.isOpen = true;
            // TODO: Switch to animate API when available
            // var animationCss = this.animate.css();
            //     animationCss
            //         .setStyles({'width':'50px'}, {'width':'400px'})
            //         .start(this.elementRef.nativeElement)
            //         .onComplete(() => animationCss.setToStyles({'width':'auto'}).start(this.elementRef.nativeElement));
            this.elementRef.nativeElement.addEventListener("transitionend", this.toggleOpenedEvent, false);
            this.setDrawerWidth(this.width);
            return new Promise(function (resolve) {
                _this._resolveOpen = function (value) {
                    resolve(value);
                    if (fireEvents) {
                        _this.opened.emit("opened");
                    }
                };
            });
        };
        /**
         * Close the Navigation Drawer. Has no effect if already closed.
         * @param fireEvents Optional flag determining whether events should be fired or not.
         * @return Promise that is resolved once the operation completes.
         */
        NavigationDrawer.prototype.close = function (fireEvents) {
            var _this = this;
            if (this._panning) {
                this.resetPan();
            }
            if (!this.isOpen) {
                return Promise.resolve();
            }
            if (fireEvents) {
                this.closing.emit("closing");
            }
            this.isOpen = false;
            this.setDrawerWidth(this._hasMimiTempl ? this.miniWidth : "");
            this.elementRef.nativeElement.addEventListener("transitionend", this.toggleClosedEvent, false);
            return new Promise(function (resolve) {
                _this._resolveClose = function (value) {
                    resolve(value);
                    if (fireEvents) {
                        _this.closed.emit("closed");
                    }
                };
            });
        };
        __decorate([core_1.Input(), __metadata('design:type', String)], NavigationDrawer.prototype, "id", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], NavigationDrawer.prototype, "position", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Boolean)], NavigationDrawer.prototype, "enableGestures", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Boolean)], NavigationDrawer.prototype, "isOpen", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Boolean)], NavigationDrawer.prototype, "pin", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Number)], NavigationDrawer.prototype, "pinThreshold", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], NavigationDrawer.prototype, "width", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], NavigationDrawer.prototype, "miniWidth", void 0);
        __decorate([core_1.Output(), __metadata('design:type', Object)], NavigationDrawer.prototype, "opening", void 0);
        __decorate([core_1.Output(), __metadata('design:type', Object)], NavigationDrawer.prototype, "opened", void 0);
        __decorate([core_1.Output(), __metadata('design:type', Object)], NavigationDrawer.prototype, "closing", void 0);
        __decorate([core_1.Output(), __metadata('design:type', Object)], NavigationDrawer.prototype, "closed", void 0);
        NavigationDrawer = __decorate([core_1.Component({
            selector: 'ig-nav-drawer',
            /* Per https://github.com/angular/angular/issues/2383 BUT https://github.com/angular/angular/issues/6053, can't use relative URLs still with SystemJS
                TODO: try https://github.com/angular/angular/issues/2991 ??
            */
            moduleId: module.id,
            template: "\n      <div class=\"ig-nav-drawer-overlay\" [class.pinned]=\"pin\" [class.hidden]=\"!isOpen\" (click)=\"close(true)\"></div>\n      <aside class=\"ig-nav-drawer\" role=\"navigation\" \n          [class.collapsed]=\"!_hasMimiTempl && !isOpen\" [class.mini]=\"_hasMimiTempl && !isOpen\" [class.pinned]=\"pin\" [class.right]=\"position == 'right'\">\n    \n          <div class=\"\" [hidden]=\"!isOpen && _hasMimiTempl\">\n              <ng-content select=\".ig-drawer-content\"></ng-content>\n          </div>                \n          <div class=\"\" [hidden]=\"isOpen\">\n              <ng-content select=\".ig-drawer-mini-content\"></ng-content>\n          </div>\n      </aside>\n      <div class=\"style-dummy\"></div>\n    ",
            providers: [touch_1.HammerGesturesManager]
        }), __param(0, core_1.Inject(core_1.ElementRef)), __param(1, core_1.Optional()), __metadata('design:paramtypes', [core_1.ElementRef, navigation_1.NavigationService, core_1.Renderer, touch_1.HammerGesturesManager])], NavigationDrawer);
        return NavigationDrawer;
    }(base_1.BaseComponent);
    exports.NavigationDrawer = NavigationDrawer;
    var NavigationDrawerModule = function () {
        function NavigationDrawerModule() {}
        NavigationDrawerModule = __decorate([core_1.NgModule({
            declarations: [NavigationDrawer],
            exports: [NavigationDrawer]
        }), __metadata('design:paramtypes', [])], NavigationDrawerModule);
        return NavigationDrawerModule;
    }();
    exports.NavigationDrawerModule = NavigationDrawerModule;
    return module.exports;
});
System.registerDynamic("zero-blocks/icon/icon", ["@angular/core"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var Icon = function () {
        function Icon() {}
        Icon = __decorate([core_1.Directive({
            selector: 'ig-icon'
        }), __metadata('design:paramtypes', [])], Icon);
        return Icon;
    }();
    exports.Icon = Icon;
    return module.exports;
});
System.registerDynamic("zero-blocks/list/list", ["@angular/core", "@angular/common"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __param = this && this.__param || function (paramIndex, decorator) {
        return function (target, key) {
            decorator(target, key, paramIndex);
        };
    };
    var core_1 = $__require("@angular/core");
    var common_1 = $__require("@angular/common");
    // ====================== LIST ================================
    // The `<ig-list>` directive is a list container for items and headers 
    var List = function () {
        function List(element) {
            this.element = element;
            this._innerStyle = "ig-list";
            this.children = [];
        }
        Object.defineProperty(List.prototype, "items", {
            get: function () {
                return this.children.filter(function (item) {
                    return item instanceof ListItem;
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(List.prototype, "headers", {
            get: function () {
                return this.children.filter(function (header) {
                    return header instanceof ListHeader;
                });
            },
            enumerable: true,
            configurable: true
        });
        List.prototype.removeChild = function (index) {
            this.children.splice(index, 1);
        };
        List.prototype.addChild = function (child) {
            this.children.push(child);
        };
        List = __decorate([core_1.Component({
            selector: 'ig-list',
            moduleId: module.id,
            template: "\n      <div #wrapper class=\"{{_innerStyle}}\" [hidden]=\"hidden\">\n        <ng-content></ng-content>\n      </div>\n      <!--<div *ngIf=\"options\" class=\"options\">\n          <button class=\"btn btn-success\"> OK </button>\n          <button class=\"btn btn-danger\"> Cancel </button>\n          <button class=\"btn btn-info\"> More info </button>\n      </div>-->\n    "
        }), __metadata('design:paramtypes', [core_1.ElementRef])], List);
        return List;
    }();
    exports.List = List;
    // ====================== HEADER ================================
    // The `<ig-header>` directive is a header intended for row items in
    // a `<ig-list>` container.
    var ListHeader = function () {
        function ListHeader(list, element) {
            this.list = list;
            this.element = element;
            this._innerStyle = "ig-list__header";
        }
        Object.defineProperty(ListHeader.prototype, "index", {
            get: function () {
                return this.list.children.indexOf(this);
            },
            enumerable: true,
            configurable: true
        });
        ListHeader.prototype.ngOnInit = function () {
            this.list.addChild(this);
        };
        ListHeader = __decorate([core_1.Component({
            selector: 'ig-list-header',
            moduleId: module.id,
            template: "\n      <div #wrapper class=\"{{_innerStyle}}\" [hidden]=\"hidden\">\n        <ng-content></ng-content>\n      </div>\n      <!--<div *ngIf=\"options\" class=\"options\">\n          <button class=\"btn btn-success\"> OK </button>\n          <button class=\"btn btn-danger\"> Cancel </button>\n          <button class=\"btn btn-info\"> More info </button>\n      </div>-->\n    "
        }), __param(0, core_1.Inject(core_1.forwardRef(function () {
            return List;
        }))), __metadata('design:paramtypes', [List, core_1.ElementRef])], ListHeader);
        return ListHeader;
    }();
    exports.ListHeader = ListHeader;
    // ====================== ITEM ================================
    // The `<ig-item>` directive is a container intended for row items in
    // a `<ig-list>` container.
    var ListItem = function () {
        function ListItem(list, element, _renderer) {
            this.list = list;
            this.element = element;
            this._renderer = _renderer;
            this._VISIBLE_AREA_ON_FULL_PAN = 40; // in pixels
            this._FRACTION_OF_WIDTH_TO_TRIGGER_GRIP = 0.5; // as a fraction of the item width
            this._initialLeft = null;
            this._innerStyle = "ig-list__item";
            this.hidden = false;
        }
        Object.defineProperty(ListItem.prototype, "index", {
            get: function () {
                return this.list.children.indexOf(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ListItem.prototype, "width", {
            get: function () {
                if (this.element && this.element.nativeElement) {
                    return this.element.nativeElement.offsetWidth;
                } else {
                    return 0;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ListItem.prototype, "left", {
            get: function () {
                return this.wrapper.nativeElement.offsetLeft;
            },
            set: function (value) {
                var val = value + "";
                if (val.indexOf("px") == -1) {
                    val += "px";
                }
                this.wrapper.nativeElement.style.left = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ListItem.prototype, "maxLeft", {
            get: function () {
                return -this.width + this._VISIBLE_AREA_ON_FULL_PAN;
            },
            enumerable: true,
            configurable: true
        });
        ListItem.prototype.ngOnInit = function () {
            this.list.addChild(this);
            this._addEventListeners();
            // Fix for default value of touch-action: none, set by Hammer.js
            this.element.nativeElement.style.touchAction = "inherit";
        };
        ListItem.prototype.ngOnDestroy = function () {
            this.list.removeChild(this.index);
        };
        ListItem.prototype._addEventListeners = function () {
            var _this = this;
            // Do not attach pan events if there is no options - no need to pan the item
            if (this._renderer && this.options) {
                this._renderer.listen(this.element.nativeElement, 'panstart', function (event) {
                    _this.panStart(event);
                });
                this._renderer.listen(this.element.nativeElement, 'panmove', function (event) {
                    _this.panMove(event);
                });
                this._renderer.listen(this.element.nativeElement, 'panend', function (event) {
                    _this.panEnd(event);
                });
            }
        };
        ListItem.prototype.cancelEvent = function (ev) {
            return this.left > 0 || this._initialLeft == null;
        };
        ListItem.prototype.panStart = function (ev) {
            this._initialLeft = this.left;
        };
        ListItem.prototype.panMove = function (ev) {
            var newLeft;
            if (this.cancelEvent(ev)) {
                return;
            }
            newLeft = this._initialLeft + ev.deltaX;
            newLeft = newLeft > 0 ? 0 : newLeft < this.maxLeft ? this.maxLeft : newLeft;
            this.left = newLeft;
        };
        ListItem.prototype.panEnd = function (ev) {
            if (this.left > 0) {
                this.rightMagneticGrip();
            } else {
                this.magneticGrip();
            }
            this._initialLeft = null;
        };
        ListItem.prototype.magneticGrip = function () {
            var left = this.left,
                partialWidth = this.width * this._FRACTION_OF_WIDTH_TO_TRIGGER_GRIP;
            if (partialWidth && left < 0 && -left > partialWidth) {
                this.leftMagneticGrip();
            } else {
                this.rightMagneticGrip();
            }
        };
        ListItem.prototype.rightMagneticGrip = function () {
            this.left = 0;
        };
        ListItem.prototype.leftMagneticGrip = function () {
            this.left = this.maxLeft;
        };
        __decorate([core_1.ViewChild('wrapper'), __metadata('design:type', core_1.ElementRef)], ListItem.prototype, "wrapper", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], ListItem.prototype, "href", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Array)], ListItem.prototype, "options", void 0);
        ListItem = __decorate([core_1.Component({
            selector: 'ig-list-item',
            moduleId: module.id,
            template: "\n      <div #wrapper class=\"{{_innerStyle}}\" [hidden]=\"hidden\">\n        <ng-content></ng-content>\n      </div>\n      <!--<div *ngIf=\"options\" class=\"options\">\n          <button class=\"btn btn-success\"> OK </button>\n          <button class=\"btn btn-danger\"> Cancel </button>\n          <button class=\"btn btn-info\"> More info </button>\n      </div>-->\n    "
        }), __param(0, core_1.Inject(core_1.forwardRef(function () {
            return List;
        }))), __metadata('design:paramtypes', [List, core_1.ElementRef, core_1.Renderer])], ListItem);
        return ListItem;
    }();
    exports.ListItem = ListItem;
    var ListModule = function () {
        function ListModule() {}
        ListModule = __decorate([core_1.NgModule({
            declarations: [List, ListItem, ListHeader],
            imports: [common_1.CommonModule],
            exports: [List, ListItem, ListHeader]
        }), __metadata('design:paramtypes', [])], ListModule);
        return ListModule;
    }();
    exports.ListModule = ListModule;
    return module.exports;
});
System.registerDynamic("zero-blocks/tabbar/tab", ["@angular/core", "@angular/common"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var common_1 = $__require("@angular/common");
    var TabBar = function () {
        function TabBar(_element) {
            this._element = _element;
            this._maxNumberTabsDisplayed = 5;
            this._itemStyle = "ig-tab-bar-inner";
            this.tabs = [];
            this.alignment = "top";
            this.selectTab = new core_1.EventEmitter();
        }
        Object.defineProperty(TabBar.prototype, "_visibleTabs", {
            get: function () {
                var _this = this;
                return this.tabs.length > this._maxNumberTabsDisplayed ? this.tabs.filter(function (tab) {
                    return tab.index < _this._maxNumberTabsDisplayed - 1;
                }) : this.tabs;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabBar.prototype, "_height", {
            get: function () {
                return this._element.nativeElement.offsetHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabBar.prototype, "_columns", {
            get: function () {
                return this.tabs.length > this._maxNumberTabsDisplayed ? this._maxNumberTabsDisplayed : this.tabs.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabBar.prototype, "tabListHeight", {
            get: function () {
                if (this._tabList) {
                    return this._tabList.nativeElement.offsetHeight;
                }
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabBar.prototype, "selectedTab", {
            get: function () {
                var selectedTabs = this.tabs.filter(function (tab) {
                    return tab.isSelected;
                });
                if (selectedTabs.length == 0) {
                    return undefined;
                } else {
                    return selectedTabs[selectedTabs.length - 1];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabBar.prototype, "selectedIndex", {
            get: function () {
                if (this.selectedTab) {
                    return this.selectedTab.index;
                }
                return undefined;
            },
            enumerable: true,
            configurable: true
        });
        TabBar.prototype.ngAfterContentInit = function () {
            // initial selection
            if (!this.selectedTab) {
                var selectableTabs = this.tabs.filter(function (tab) {
                    return !tab.isDisabled;
                }),
                    tab = selectableTabs[0];
                if (tab) {
                    this.select(tab.index);
                }
            }
        };
        TabBar.prototype.ngAfterViewInit = function () {
            var self = this;
            this.tabs.forEach(function (tab) {
                var tabListHeight = self.tabListHeight;
                tab.height = self._height - tabListHeight;
                if (self.alignment == "top") {
                    tab.marginTop = tabListHeight;
                } else if (self.alignment == "bottom") {
                    tab.marginTop = 0;
                }
            });
        };
        TabBar.prototype.add = function (tab) {
            var _this = this;
            this.tabs.push(tab);
            this.tabs.forEach(function (tab) {
                tab.columnCount = _this._columns;
            });
        };
        TabBar.prototype.remove = function (index) {
            var tab;
            if (!this._validateTabIndex(index)) {
                return;
            }
            tab = this.tabs[index];
            if (tab.isSelected) {
                tab.isSelected = false;
            }
            this.tabs.splice(index, 1);
        };
        TabBar.prototype.select = function (index) {
            var tab,
                self = this;
            if (!this._validateTabIndex(index)) {
                return;
            }
            tab = this.tabs[index];
            if (tab.isDisabled) {
                return;
            }
            this.tabs.forEach(function (tab) {
                if (tab.index != index) {
                    self.deselect(tab.index);
                }
            });
            tab.isSelected = true;
            this.selectTab.emit({ index: index, tab: tab });
        };
        TabBar.prototype.deselect = function (index) {
            var tab;
            if (!this._validateTabIndex(index)) {
                return;
            }
            tab = this.tabs[index];
            if (!tab.isDisabled && tab.isSelected) {
                tab.isSelected = false;
            }
        };
        TabBar.prototype._selectTabMore = function () {
            alert("Tab More is clicked");
        };
        TabBar.prototype._validateTabIndex = function (index) {
            return index <= this.tabs.length - 1 && index >= 0;
        };
        __decorate([core_1.ViewChild('unorderedList'), __metadata('design:type', core_1.ElementRef)], TabBar.prototype, "_tabList", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], TabBar.prototype, "alignment", void 0);
        __decorate([core_1.Output(), __metadata('design:type', Object)], TabBar.prototype, "selectTab", void 0);
        TabBar = __decorate([core_1.Component({
            selector: 'ig-tab-bar',
            moduleId: module.id,
            template: "\n      <div class=\"{{_itemStyle}}\">\n      \t<ng-content></ng-content>\n      \t<ul #unorderedList class=\"{{_itemStyle}}__menu {{_itemStyle}}__menu--{{alignment}}\">\n      \t\t<li *ngFor=\"let tab of _visibleTabs\" class=\"{{_itemStyle}}__menu-item\" [class.ig-tab-bar-inner__menu-item--selected]=\"tab.isSelected\" [class.ig-tab-bar-inner__menu-item--disabled]=\"tab.isDisabled\" (click)=\"tab.select()\" >\n      \t\t\t<div ngClass=\"tab-icon\">\n      \t\t\t\t<i class=\"material-icons\">{{tab.icon}}</i>\n      \t\t\t\t<span [class.ig-badge--hidden]=\"tab._changesCount == 0\" class=\"ig-badge\">{{tab._changesCount}}</span>\n      \t\t\t</div>\n      \t\t\t<div ngClass=\"tab-label\">{{tab.label}}</div>\n      \t\t\t<div ngClass=\"tab-color tab-color--{{tab.color}}\"></div>\n      \t\t</li>\n      \t\t<li class=\"{{_itemStyle}}__menu-item\" *ngIf=\"tabs.length > 5\" (click)=\"_selectTabMore()\">\n      \t\t\t<div ngClass=\"tab-icon\">\n      \t\t\t\t<i class=\"material-icons\">more_horiz</i>\n      \t\t\t\t <!--<span [class.hidden]=\"tab._changesCount == 0\" class=\"badge\">{{tab._changesCount}}</span> -->\n      \t\t\t</div>\n      \t\t\t<div ngClass=\"tab-label\">More</div>\n      \t\t</li>\n      \t</ul>\n      </div>\n    "
        }), __metadata('design:paramtypes', [core_1.ElementRef])], TabBar);
        return TabBar;
    }();
    exports.TabBar = TabBar;
    var Tab = function () {
        function Tab(_tabBar, _element) {
            this._tabBar = _tabBar;
            this._element = _element;
            this._itemStyle = "ig-tab-inner";
            this._changesCount = 0; // changes and updates accordingly applied to the tab.
            this.isSelected = false;
            // Indirectly defines the width of the tab.
            this.columnCount = 0;
            this._tabBar.add(this);
        }
        Object.defineProperty(Tab.prototype, "index", {
            get: function () {
                return this._tabBar.tabs.indexOf(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Tab.prototype, "isDisabled", {
            get: function () {
                return this.disabled !== undefined;
            },
            set: function (value) {
                this.disabled = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Tab.prototype, "height", {
            get: function () {
                return this.wrapper.nativeElement.style.height;
            },
            set: function (value) {
                this.wrapper.nativeElement.style.height = value + "px";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Tab.prototype, "marginTop", {
            get: function () {
                return this.wrapper.nativeElement.style.marginTop;
            },
            set: function (value) {
                this.wrapper.nativeElement.style.marginTop = value + "px";
            },
            enumerable: true,
            configurable: true
        });
        Tab.prototype.select = function () {
            if (this.href) {}
            this._tabBar.select(this.index);
        };
        Tab.prototype.deselect = function () {
            this._tabBar.deselect(this.index);
        };
        __decorate([core_1.ViewChild('wrapper'), __metadata('design:type', core_1.ElementRef)], Tab.prototype, "wrapper", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], Tab.prototype, "label", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], Tab.prototype, "icon", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Boolean)], Tab.prototype, "disabled", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], Tab.prototype, "href", void 0);
        __decorate([
        // TODO - need to be disccussed
        core_1.Input(), __metadata('design:type', String)], Tab.prototype, "color", void 0);
        Tab = __decorate([core_1.Component({
            selector: 'ig-tab',
            moduleId: module.id,
            template: "\n      <div #wrapper class=\"{{_itemStyle}}\" [class.selected]=\"isSelected\" >\n      \t<ng-content></ng-content>\n      </div>\n    ",
            host: {
                '[class]': '"col-" + columnCount'
            }
        }), __metadata('design:paramtypes', [TabBar, core_1.ElementRef])], Tab);
        return Tab;
    }();
    exports.Tab = Tab;
    var TabBarModule = function () {
        function TabBarModule() {}
        TabBarModule = __decorate([core_1.NgModule({
            declarations: [TabBar, Tab],
            imports: [common_1.CommonModule],
            exports: [TabBar, Tab]
        }), __metadata('design:paramtypes', [])], TabBarModule);
        return TabBarModule;
    }();
    exports.TabBarModule = TabBarModule;
    return module.exports;
});
System.registerDynamic("zero-blocks/carousel/carousel", ["@angular/core", "@angular/common"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var common_1 = $__require("@angular/common");
    (function (Direction) {
        Direction[Direction["NONE"] = 0] = "NONE";
        Direction[Direction["NEXT"] = 1] = "NEXT";
        Direction[Direction["PREV"] = 2] = "PREV";
    })(exports.Direction || (exports.Direction = {}));
    var Direction = exports.Direction;
    var Carousel = function () {
        function Carousel(element_ref, renderer) {
            this.element_ref = element_ref;
            this.renderer = renderer;
            this.loop = true;
            this.pause = true;
            this.navigation = true;
            this.slideChanged = new core_1.EventEmitter();
            this.slideAdded = new core_1.EventEmitter();
            this.slideRemoved = new core_1.EventEmitter();
            this.carouselPaused = new core_1.EventEmitter();
            this.carouselPlaying = new core_1.EventEmitter();
            this.slides = [];
            this._total = 0;
            this._addEventListeners(renderer);
        }
        Object.defineProperty(Carousel.prototype, "interval", {
            get: function () {
                return this._interval;
            },
            set: function (value) {
                this._interval = +value;
                this._restartInterval();
            },
            enumerable: true,
            configurable: true
        });
        Carousel.prototype.ngOnDestroy = function () {
            this._destroyed = true;
            if (this._lastInterval) {
                clearInterval(this._lastInterval);
            }
        };
        Object.defineProperty(Carousel.prototype, "total", {
            get: function () {
                return this._total;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Carousel.prototype, "current", {
            get: function () {
                return !this._currentSlide ? 0 : this._currentSlide.index;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Carousel.prototype, "isPlaying", {
            get: function () {
                return this._playing;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Carousel.prototype, "isDestroyed", {
            get: function () {
                return this._destroyed;
            },
            enumerable: true,
            configurable: true
        });
        Carousel.prototype.get = function (index) {
            for (var _i = 0, _a = this.slides; _i < _a.length; _i++) {
                var each = _a[_i];
                if (each.index === index) {
                    return each;
                }
            }
        };
        Carousel.prototype.add = function (slide) {
            slide.index = this.total;
            this.slides.push(slide);
            this._total += 1;
            if (this.total === 1 || slide.active) {
                this.select(slide);
                if (this.total === 1) {
                    this.play();
                }
            } else {
                slide.active = false;
            }
            this.slideAdded.emit(this);
        };
        Carousel.prototype.remove = function (slide) {
            this.slides.splice(slide.index, 1);
            this._total -= 1;
            if (!this.total) {
                this._currentSlide = null;
                return;
            }
            for (var i = 0; i < this.total; i++) {
                this.slides[i].index = i;
            }
            this.slideRemoved.emit(this);
        };
        Carousel.prototype.select = function (slide, direction) {
            if (direction === void 0) {
                direction = Direction.NONE;
            }
            var new_index = slide.index;
            if (direction === Direction.NONE) {
                direction = new_index > this.current ? Direction.NEXT : Direction.PREV;
            }
            if (slide && slide !== this._currentSlide) {
                this._moveTo(slide, direction);
            }
        };
        Carousel.prototype.next = function () {
            var index = (this.current + 1) % this.total;
            if (index === 0 && !this.loop) {
                this.stop();
                return;
            }
            return this.select(this.get(index), Direction.NEXT);
        };
        Carousel.prototype.prev = function () {
            var index = this.current - 1 < 0 ? this.total - 1 : this.current - 1;
            if (!this.loop && index === this.total - 1) {
                this.stop();
                return;
            }
            return this.select(this.get(index), Direction.PREV);
        };
        Carousel.prototype.play = function () {
            if (!this._playing) {
                this._playing = true;
                this.carouselPlaying.emit(this);
                this._restartInterval();
            }
        };
        Carousel.prototype.stop = function () {
            if (this.pause) {
                this._playing = false;
                this.carouselPaused.emit(this);
                this._resetInterval();
            }
        };
        Carousel.prototype._moveTo = function (slide, direction) {
            if (this._destroyed) {
                return;
            }
            slide.direction = direction;
            slide.active = true;
            if (this._currentSlide) {
                this._currentSlide.direction = direction;
                this._currentSlide.active = false;
            }
            this._currentSlide = slide;
            this.slideChanged.emit(this);
            this._restartInterval();
        };
        Carousel.prototype._resetInterval = function () {
            if (this._lastInterval) {
                clearInterval(this._lastInterval);
                this._lastInterval = null;
            }
        };
        Carousel.prototype._restartInterval = function () {
            var _this = this;
            this._resetInterval();
            if (!isNaN(this.interval) && this.interval > 0) {
                this._lastInterval = setInterval(function () {
                    var tick = +_this.interval;
                    if (_this._playing && _this.total && !isNaN(tick) && tick > 0) {
                        _this.next();
                    } else {
                        _this.stop();
                    }
                }, this.interval);
            }
        };
        Carousel.prototype._addEventListeners = function (renderer) {
            // Swipe events
            var _this = this;
            renderer.listen(this.element_ref.nativeElement, 'swipeleft', function (event) {
                _this.prev();
            });
            renderer.listen(this.element_ref.nativeElement, 'swiperight', function (event) {
                _this.next();
            });
            // Tap
            renderer.listen(this.element_ref.nativeElement, 'tap', function (event) {
                if (_this._playing) {
                    _this.stop();
                } else {
                    _this.play();
                }
            });
            // Keydown for arrow keys
            renderer.listen(this.element_ref.nativeElement, 'keydown', function (event) {
                switch (event.key) {
                    case "ArrowLeft":
                        _this.prev();
                        break;
                    case "ArrowRight":
                        _this.next();
                        break;
                    default:
                        return;
                }
            });
        };
        __decorate([core_1.Input(), __metadata('design:type', Boolean)], Carousel.prototype, "loop", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Boolean)], Carousel.prototype, "pause", void 0);
        __decorate([core_1.Input("interval"), __metadata('design:type', Number)], Carousel.prototype, "interval", null);
        __decorate([core_1.Input(), __metadata('design:type', Boolean)], Carousel.prototype, "navigation", void 0);
        __decorate([core_1.Output(), __metadata('design:type', Object)], Carousel.prototype, "slideChanged", void 0);
        __decorate([core_1.Output(), __metadata('design:type', Object)], Carousel.prototype, "slideAdded", void 0);
        __decorate([core_1.Output(), __metadata('design:type', Object)], Carousel.prototype, "slideRemoved", void 0);
        __decorate([core_1.Output(), __metadata('design:type', Object)], Carousel.prototype, "carouselPaused", void 0);
        __decorate([core_1.Output(), __metadata('design:type', Object)], Carousel.prototype, "carouselPlaying", void 0);
        Carousel = __decorate([core_1.Component({
            selector: 'ig-carousel',
            moduleId: module.id,
            template: "\n      <div tabindex=\"1\" (mouseenter)=\"stop()\" (mouseleave)=\"play()\" (keydown)=\"($event)\" class=\"ig-carousel\">\n          <ul class=\"ig-carousel-indicators\" [hidden]=\"slides.length <= 1\">\n              <li *ngFor=\"let slide of slides\" [class.active]=\"slide.active === true\" (click)=\"select(slide)\"></li>\n          </ul>\n          <div class=\"ig-carousel-inner\">\n              <ng-content></ng-content>\n          </div>\n          <div template=\"ngIf navigation\">\n              <a class=\"left ig-carousel-control\" (click)=\"prev()\" [hidden]=\"!slides.length\">\n                  <span>Prev</span>\n              </a>\n              <a class=\"right ig-carousel-control\" (click)=\"next()\" [hidden]=\"!slides.length\">\n                  <span>Next</span>\n              </a>\n          </div>\n      </div>\n    "
        }), __metadata('design:paramtypes', [core_1.ElementRef, core_1.Renderer])], Carousel);
        return Carousel;
    }();
    exports.Carousel = Carousel;
    var Slide = function () {
        function Slide(carousel, element_ref) {
            this.carousel = carousel;
            this.element_ref = element_ref;
        }
        Slide.prototype.ngOnInit = function () {
            this.carousel.add(this);
        };
        Slide.prototype.ngOnDestroy = function () {
            this.carousel.remove(this);
        };
        __decorate([core_1.Input(), __metadata('design:type', Number)], Slide.prototype, "index", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Number)], Slide.prototype, "direction", void 0);
        __decorate([core_1.HostBinding('class.active'), core_1.Input(), __metadata('design:type', Boolean)], Slide.prototype, "active", void 0);
        Slide = __decorate([core_1.Component({
            selector: 'ig-slide',
            moduleId: module.id,
            template: "\n      <div [class.active]=\"active\" class=\"item\">\n          <ng-content></ng-content>\n      </div>\n    "
        }), __metadata('design:paramtypes', [Carousel, core_1.ElementRef])], Slide);
        return Slide;
    }();
    exports.Slide = Slide;
    var CarouselModule = function () {
        function CarouselModule() {}
        CarouselModule = __decorate([core_1.NgModule({
            declarations: [Carousel, Slide],
            imports: [common_1.CommonModule],
            exports: [Carousel, Slide]
        }), __metadata('design:paramtypes', [])], CarouselModule);
        return CarouselModule;
    }();
    exports.CarouselModule = CarouselModule;
    return module.exports;
});
System.registerDynamic("zero-blocks/input/input", ["@angular/core"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var IgInput = function () {
        function IgInput(el) {
            this.el = el;
        }
        IgInput.prototype.onFocus = function (event) {
            this.focused = true;
        };
        IgInput.prototype.onBlur = function (event) {
            this.focused = false;
        };
        Object.defineProperty(IgInput.prototype, "filled", {
            get: function () {
                var value = this.el.nativeElement.value;
                return value && value !== '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgInput.prototype, "placeholder", {
            get: function () {
                return this.el.nativeElement.getAttribute('placeholder') && !this.filled;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([core_1.HostListener('focus', ['$event']), __metadata('design:type', Function), __metadata('design:paramtypes', [Object]), __metadata('design:returntype', void 0)], IgInput.prototype, "onFocus", null);
        __decorate([core_1.HostListener('blur', ['$event']), __metadata('design:type', Function), __metadata('design:paramtypes', [Object]), __metadata('design:returntype', void 0)], IgInput.prototype, "onBlur", null);
        IgInput = __decorate([core_1.Directive({
            selector: '[igInput]',
            host: {
                '[class.ig-form-group__input]': 'true',
                '[class.ig-form-group__input--filled]': 'filled',
                '[class.ig-form-group__input--focused]': 'focused',
                '[class.ig-form-group__input--placeholder]': 'placeholder'
            }
        }), __metadata('design:paramtypes', [core_1.ElementRef])], IgInput);
        return IgInput;
    }();
    exports.IgInput = IgInput;
    return module.exports;
});
System.registerDynamic("zero-blocks/checkbox/checkbox", ["@angular/core", "@angular/forms"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var forms_1 = $__require("@angular/forms");
    var noop = function () {};
    var nextId = 0;
    function MakeProvider(type) {
        return {
            provide: forms_1.NG_VALUE_ACCESSOR,
            useExisting: core_1.forwardRef(function () {
                return type;
            }),
            multi: true
        };
    }
    var IgCheckbox = function () {
        function IgCheckbox() {
            this.id = "ig-checkbox-" + nextId++;
            this.disabled = false;
            this.tabindex = null;
            this.checked = false;
            this.change = new core_1.EventEmitter();
            this.focused = false;
            this._onTouchedCallback = noop;
            this._onChangeCallback = noop;
        }
        IgCheckbox.prototype.onChange = function (event) {
            if (this.disabled) {
                return;
            }
            this.checked = !this.checked;
            this._onChangeCallback(this.checked);
            this.change.emit(event);
        };
        IgCheckbox.prototype.onFocus = function (event) {
            this.focused = true;
        };
        IgCheckbox.prototype.onBlur = function (event) {
            this.focused = false;
            this._onTouchedCallback();
        };
        IgCheckbox.prototype.writeValue = function (value) {
            if (this.disabled) {
                return;
            }
            this._value = value;
            this.checked = !!this._value;
        };
        IgCheckbox.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        IgCheckbox.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        __decorate([core_1.Input(), __metadata('design:type', Object)], IgCheckbox.prototype, "value", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], IgCheckbox.prototype, "id", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], IgCheckbox.prototype, "name", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Boolean)], IgCheckbox.prototype, "disabled", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Number)], IgCheckbox.prototype, "tabindex", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Boolean)], IgCheckbox.prototype, "checked", void 0);
        __decorate([core_1.Output(), __metadata('design:type', Object)], IgCheckbox.prototype, "change", void 0);
        __decorate([core_1.ViewChild('checkbox'), __metadata('design:type', Object)], IgCheckbox.prototype, "nativeCheckbox", void 0);
        IgCheckbox = __decorate([core_1.Component({
            selector: "ig-checkbox",
            moduleId: module.id,
            template: "\n      <div class=\"ig-control\">\n          <input class=\"ig-control__cbx\" #checkbox type=\"checkbox\"\n              [attr.id]=\"id\"\n              [attr.name]=\"name\"\n              [attr.value]=\"value\"\n              [attr.tabindex]=\"tabindex\"\n              [attr.disabled]=\"disabled ? true : null\"\n              [checked]=\"checked\"\n              (change)=\"onChange($event)\"\n              (focus)=\"onFocus($event)\"\n              (blur)=\"onBlur($event)\">\n          <label class=\"ig-control__label\" [attr.for]=\"id\">\n              <ng-content></ng-content>\n          </label>\n      </div>\n    ",
            providers: [MakeProvider(IgCheckbox)]
        }), __metadata('design:paramtypes', [])], IgCheckbox);
        return IgCheckbox;
    }();
    exports.IgCheckbox = IgCheckbox;
    var CheckboxModule = function () {
        function CheckboxModule() {}
        CheckboxModule = __decorate([core_1.NgModule({
            declarations: [IgCheckbox],
            exports: [IgCheckbox]
        }), __metadata('design:paramtypes', [])], CheckboxModule);
        return CheckboxModule;
    }();
    exports.CheckboxModule = CheckboxModule;
    return module.exports;
});
System.registerDynamic("zero-blocks/radio/radio", ["@angular/core", "@angular/forms"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var forms_1 = $__require("@angular/forms");
    var nextId = 0;
    var noop = function () {};
    function MakeProvider(type) {
        return {
            provide: forms_1.NG_VALUE_ACCESSOR,
            useExisting: core_1.forwardRef(function () {
                return type;
            }),
            multi: true
        };
    }
    var IgRadio = function () {
        function IgRadio() {
            this.id = "ig-radio-" + nextId++;
            this.tabindex = null;
            this.change = new core_1.EventEmitter();
            this._onTouchedCallback = noop;
            this._onChangeCallback = noop;
        }
        IgRadio.prototype.onChange = function (event) {
            this.select();
            this.change.emit(event);
        };
        IgRadio.prototype.select = function () {
            this.checked = true;
            this._onChangeCallback(this.value);
        };
        IgRadio.prototype.writeValue = function (value) {
            this._value = value;
            this.checked = this._value == this.value;
        };
        IgRadio.prototype.onFocus = function (event) {
            this.focused = true;
        };
        IgRadio.prototype.onBlur = function (event) {
            this.focused = false;
            this._onTouchedCallback();
        };
        IgRadio.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        IgRadio.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        __decorate([core_1.Input(), __metadata('design:type', Object)], IgRadio.prototype, "value", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], IgRadio.prototype, "id", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], IgRadio.prototype, "name", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Boolean)], IgRadio.prototype, "disabled", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Number)], IgRadio.prototype, "tabindex", void 0);
        __decorate([core_1.Output(), __metadata('design:type', core_1.EventEmitter)], IgRadio.prototype, "change", void 0);
        __decorate([core_1.ViewChild('radio'), __metadata('design:type', Object)], IgRadio.prototype, "nativeRadio", void 0);
        IgRadio = __decorate([core_1.Component({
            selector: 'ig-radio',
            moduleId: module.id,
            template: "\n      <div class=\"ig-control\">\n          <input class=\"ig-control__radio\" type=\"radio\" #radio\n              [attr.id]=\"id\"\n              [attr.name]=\"name\"\n              [attr.value]=\"value\"\n              [attr.tabindex]=\"tabindex\"\n              [disabled]=\"disabled\"\n              [checked]=\"checked\"\n              (change)=\"onChange($event)\"\n              (focus)=\"onFocus($event)\"\n              (blur)=\"onBlur($event)\"/>\n          <label class =\"ig-control__label\" [attr.for]=\"id\"><ng-content></ng-content></label>\n      </div>\n    ",
            providers: [MakeProvider(IgRadio)]
        }), __metadata('design:paramtypes', [])], IgRadio);
        return IgRadio;
    }();
    exports.IgRadio = IgRadio;
    var IgRadioModule = function () {
        function IgRadioModule() {}
        IgRadioModule = __decorate([core_1.NgModule({
            declarations: [IgRadio],
            exports: [IgRadio]
        }), __metadata('design:paramtypes', [])], IgRadioModule);
        return IgRadioModule;
    }();
    exports.IgRadioModule = IgRadioModule;
    return module.exports;
});
System.registerDynamic("zero-blocks/label/label", ["@angular/core"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var Label = function () {
        function Label(el, renderer) {
            renderer.setElementClass(el.nativeElement, 'ig-form-group__label', true);
        }
        Label = __decorate([core_1.Directive({
            selector: '[igLabel]'
        }), __metadata('design:paramtypes', [core_1.ElementRef, core_1.Renderer])], Label);
        return Label;
    }();
    exports.Label = Label;
    return module.exports;
});
System.registerDynamic("zero-blocks/switch/switch", ["@angular/core", "@angular/forms"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var forms_1 = $__require("@angular/forms");
    var noop = function () {};
    var nextId = 0;
    function MakeProvider(type) {
        return {
            provide: forms_1.NG_VALUE_ACCESSOR,
            useExisting: core_1.forwardRef(function () {
                return type;
            }),
            multi: true
        };
    }
    var IgSwitch = function () {
        function IgSwitch() {
            this.id = "ig-switch-" + nextId++;
            this.disabled = false;
            this.tabindex = null;
            this.checked = false;
            this.change = new core_1.EventEmitter();
            this.focused = false;
            this._onTouchedCallback = noop;
            this._onChangeCallback = noop;
        }
        IgSwitch.prototype.onChange = function (event) {
            if (this.disabled) {
                return;
            }
            this.checked = !this.checked;
            this._onChangeCallback(this.checked);
            this.change.emit(event);
        };
        IgSwitch.prototype.onFocus = function (event) {
            this.focused = true;
        };
        IgSwitch.prototype.onBlur = function (event) {
            this.focused = false;
            this._onTouchedCallback();
        };
        IgSwitch.prototype.writeValue = function (value) {
            if (this.disabled) {
                return;
            }
            this._value = value;
            this.checked = this._value;
        };
        IgSwitch.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        IgSwitch.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        __decorate([core_1.Input(), __metadata('design:type', Object)], IgSwitch.prototype, "value", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], IgSwitch.prototype, "id", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], IgSwitch.prototype, "name", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Boolean)], IgSwitch.prototype, "disabled", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Number)], IgSwitch.prototype, "tabindex", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Boolean)], IgSwitch.prototype, "checked", void 0);
        __decorate([core_1.Output(), __metadata('design:type', Object)], IgSwitch.prototype, "change", void 0);
        __decorate([core_1.ViewChild('checkbox'), __metadata('design:type', Object)], IgSwitch.prototype, "nativeCheckbox", void 0);
        IgSwitch = __decorate([core_1.Component({
            selector: "ig-switch",
            moduleId: module.id,
            template: "\n      <div class=\"ig-control\">\n          <input class=\"ig-control__switch\" #checkbox type=\"checkbox\"\n              [attr.id]=\"id\"\n              [attr.name]=\"name\"\n              [attr.value]=\"value\"\n              [attr.tabindex]=\"tabindex\"\n              [disabled]=\"disabled\"\n              [checked]=\"checked\"\n              (change)=\"onChange($event)\"\n              (focus)=\"onFocus($event)\"\n              (blur)=\"onBlur($event)\">\n          <span class=\"ig-control__text\">\n              <ng-content></ng-content>\n          </span>\n          <label class=\"ig-control__label\" [attr.for]=\"id\">\n          </label>\n      </div>\n    ",
            providers: [MakeProvider(IgSwitch)]
        }), __metadata('design:paramtypes', [])], IgSwitch);
        return IgSwitch;
    }();
    exports.IgSwitch = IgSwitch;
    var SwitchModule = function () {
        function SwitchModule() {}
        SwitchModule = __decorate([core_1.NgModule({
            declarations: [IgSwitch],
            exports: [IgSwitch]
        }), __metadata('design:paramtypes', [])], SwitchModule);
        return SwitchModule;
    }();
    exports.SwitchModule = SwitchModule;
    return module.exports;
});
System.registerDynamic("zero-blocks/avatar/avatar", ["@angular/core", "@angular/common"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var common_1 = $__require("@angular/common");
    (function (Size) {
        Size[Size["SMALL"] = 0] = "SMALL";
        Size[Size["MEDIUM"] = 1] = "MEDIUM";
        Size[Size["LARGE"] = 2] = "LARGE";
    })(exports.Size || (exports.Size = {}));
    var Size = exports.Size;
    ;
    var Avatar = function () {
        function Avatar(element_ref, renderer) {
            this.element_ref = element_ref;
            this.renderer = renderer;
            this.roundShape = "false";
            this.color = 'white';
            this.fontname = "Titillium Web";
            this._icon = "android";
            this.SizeEnum = Size;
            this._addEventListeners(renderer);
        }
        Object.defineProperty(Avatar.prototype, "size", {
            get: function () {
                return this._size === undefined ? "small" : this._size;
            },
            set: function (value) {
                var sizeType = this.SizeEnum[value.toUpperCase()];
                if (sizeType === undefined) {
                    this._size = "small";
                } else {
                    this._size = value.toLowerCase();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Avatar.prototype, "bgColor", {
            get: function () {
                return this._bgColor;
            },
            set: function (value) {
                var color = value === "" ? "lightgrey" : value;
                this._bgColor = color;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Avatar.prototype, "srcImage", {
            get: function () {
                return this.image ? this.image.nativeElement.src : "";
            },
            set: function (value) {
                this.image.nativeElement.src = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Avatar.prototype, "isRounded", {
            get: function () {
                return this.roundShape.toUpperCase() === "TRUE" ? true : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Avatar.prototype, "icon", {
            get: function () {
                return this._icon;
            },
            set: function (value) {
                this._icon = value;
            },
            enumerable: true,
            configurable: true
        });
        Avatar.prototype.ngAfterViewInit = function () {
            if (this.initials && this.image) {
                var src = this.generateInitials(parseInt(this.image.nativeElement.width));
                this.image.nativeElement.src = src;
            }
        };
        Avatar.prototype.generateInitials = function (size) {
            var canvas = document.createElement('canvas'),
                fontSize = size / 2,
                ctx;
            canvas.width = size;
            canvas.height = size;
            ctx = canvas.getContext('2d');
            ctx.fillStyle = this.bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.textAlign = "center";
            ctx.fillStyle = this.color;
            ctx.font = fontSize + ("px " + this.fontname);
            ctx.fillText(this.initials.toUpperCase(), size / 2, size - size / 2 + fontSize / 3);
            return canvas.toDataURL("image/png");
        };
        Avatar.prototype._addEventListeners = function (renderer) {};
        __decorate([core_1.ViewChild('image'), __metadata('design:type', core_1.ElementRef)], Avatar.prototype, "image", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], Avatar.prototype, "initials", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], Avatar.prototype, "src", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], Avatar.prototype, "roundShape", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], Avatar.prototype, "color", void 0);
        __decorate([core_1.Input("size"), __metadata('design:type', String)], Avatar.prototype, "size", null);
        __decorate([core_1.Input("bgColor"), __metadata('design:type', String)], Avatar.prototype, "bgColor", null);
        __decorate([core_1.Input("icon"), __metadata('design:type', String)], Avatar.prototype, "icon", null);
        Avatar = __decorate([core_1.Component({
            selector: 'ig-avatar',
            moduleId: module.id,
            template: "\n      <div class=\"ig-avatar\">\n          <img #image *ngIf=\"src || initials\" src=\"{{src}}\" class=\"ig-avatar--image ig-avatar--{{size}}\" [class.ig-avatar--rounded]=\"isRounded\" [style.backgroundColor]=\"bgColor\" />\n          <span *ngIf=\"!src && !initials\" class=\"ig-avatar--{{size}} ig-avatar--icon\" [class.ig-avatar--rounded]=\"isRounded\" [style.backgroundColor]=\"bgColor\" [style.color]=\"color\">\n              <i class=\"material-icons\">{{icon}}</i>\n          </span>\n          <ng-content></ng-content>\n      </div>\n    "
        }), __metadata('design:paramtypes', [core_1.ElementRef, core_1.Renderer])], Avatar);
        return Avatar;
    }();
    exports.Avatar = Avatar;
    var AvatarModule = function () {
        function AvatarModule() {}
        AvatarModule = __decorate([core_1.NgModule({
            declarations: [Avatar],
            imports: [common_1.CommonModule],
            exports: [Avatar]
        }), __metadata('design:paramtypes', [])], AvatarModule);
        return AvatarModule;
    }();
    exports.AvatarModule = AvatarModule;
    return module.exports;
});
System.registerDynamic("zero-blocks/layout/layout", ["@angular/core"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var LayoutDirective = function () {
        function LayoutDirective() {
            this.dir = "row";
            this.reverse = false;
            this.wrap = "nowrap";
            this.justify = "flex-start";
            this.itemAlign = "flex-start";
            this.display = 'flex';
        }
        Object.defineProperty(LayoutDirective.prototype, "flexwrap", {
            get: function () {
                return this.wrap;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayoutDirective.prototype, "justifycontent", {
            get: function () {
                return this.justify;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayoutDirective.prototype, "align", {
            get: function () {
                return this.itemAlign;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayoutDirective.prototype, "direction", {
            get: function () {
                if (this.reverse) {
                    return this.dir == 'row' ? 'row-reverse' : 'column-reverse';
                }
                return this.dir == 'row' ? 'row' : 'column';
            },
            enumerable: true,
            configurable: true
        });
        __decorate([core_1.Input(), __metadata('design:type', String)], LayoutDirective.prototype, "dir", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Boolean)], LayoutDirective.prototype, "reverse", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], LayoutDirective.prototype, "wrap", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], LayoutDirective.prototype, "justify", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], LayoutDirective.prototype, "itemAlign", void 0);
        __decorate([core_1.HostBinding('style.display'), __metadata('design:type', Object)], LayoutDirective.prototype, "display", void 0);
        __decorate([core_1.HostBinding('style.flex-wrap'), __metadata('design:type', Object)], LayoutDirective.prototype, "flexwrap", null);
        __decorate([core_1.HostBinding('style.justify-content'), __metadata('design:type', Object)], LayoutDirective.prototype, "justifycontent", null);
        __decorate([core_1.HostBinding('style.align-content'), __metadata('design:type', Object)], LayoutDirective.prototype, "align", null);
        __decorate([core_1.HostBinding('style.flex-direction'), __metadata('design:type', Object)], LayoutDirective.prototype, "direction", null);
        LayoutDirective = __decorate([core_1.Directive({
            selector: '[layout]'
        }), __metadata('design:paramtypes', [])], LayoutDirective);
        return LayoutDirective;
    }();
    exports.LayoutDirective = LayoutDirective;
    var FlexDirective = function () {
        function FlexDirective() {
            this.grow = 1;
            this.shrink = 1;
            this.order = 0;
        }
        Object.defineProperty(FlexDirective.prototype, "style", {
            get: function () {
                return this.grow + " " + this.shrink;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FlexDirective.prototype, "itemorder", {
            get: function () {
                return this.order || 0;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([core_1.Input(), __metadata('design:type', Number)], FlexDirective.prototype, "grow", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Number)], FlexDirective.prototype, "shrink", void 0);
        __decorate([core_1.Input(), __metadata('design:type', String)], FlexDirective.prototype, "flex", void 0);
        __decorate([core_1.Input(), __metadata('design:type', Number)], FlexDirective.prototype, "order", void 0);
        __decorate([core_1.HostBinding('style.flex'), __metadata('design:type', Object)], FlexDirective.prototype, "style", null);
        __decorate([core_1.HostBinding('style.order'), __metadata('design:type', Object)], FlexDirective.prototype, "itemorder", null);
        FlexDirective = __decorate([core_1.Directive({
            selector: '[flex]'
        }), __metadata('design:paramtypes', [])], FlexDirective);
        return FlexDirective;
    }();
    exports.FlexDirective = FlexDirective;
    var IgLayout = function () {
        function IgLayout() {}
        IgLayout = __decorate([core_1.NgModule({
            declarations: [LayoutDirective, FlexDirective],
            exports: [FlexDirective, LayoutDirective]
        }), __metadata('design:paramtypes', [])], IgLayout);
        return IgLayout;
    }();
    exports.IgLayout = IgLayout;
    return module.exports;
});
System.registerDynamic("zero-blocks/modal/modal", ["@angular/core", "@angular/common"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var common_1 = $__require("@angular/common");
    var Modal = function () {
        function Modal() {
            this.closeOnClick = true;
            this.onOpen = new core_1.EventEmitter();
            this.onClose = new core_1.EventEmitter();
            this.isOpen = false;
        }
        Modal.prototype.open = function () {
            if (this.isOpen) {
                return;
            }
            this.isOpen = true;
            this.onOpen.emit(this);
            this.modalEl.nativeElement.classList.add('ig-modal');
        };
        Modal.prototype.close = function () {
            if (!this.isOpen) {
                return;
            }
            this.isOpen = false;
            this.onClose.emit(this);
            this.modalEl.nativeElement.classList.remove('ig-modal');
        };
        __decorate([core_1.Input(), __metadata('design:type', Object)], Modal.prototype, "closeOnClick", void 0);
        __decorate([core_1.Output(), __metadata('design:type', Object)], Modal.prototype, "onOpen", void 0);
        __decorate([core_1.Output(), __metadata('design:type', Object)], Modal.prototype, "onClose", void 0);
        __decorate([core_1.ViewChild('modal'), __metadata('design:type', core_1.ElementRef)], Modal.prototype, "modalEl", void 0);
        Modal = __decorate([core_1.Component({
            selector: 'ig-modal',
            moduleId: module.id,
            template: "\n      <div #modal\n          tabindex=\"-1\"\n          [ngStyle]=\"{ display: isOpen ? 'block' : 'none' }\"\n          (click)=\"closeOnClick ? close() : 0\">\n          <div class=\"ig-modal__window\">\n              <ng-content></ng-content>\n          <div>\n      </div>\n    "
        }), __metadata('design:paramtypes', [])], Modal);
        return Modal;
    }();
    exports.Modal = Modal;
    var ModalModule = function () {
        function ModalModule() {}
        ModalModule = __decorate([core_1.NgModule({
            declarations: [Modal],
            exports: [Modal],
            imports: [common_1.CommonModule]
        }), __metadata('design:paramtypes', [])], ModalModule);
        return ModalModule;
    }();
    exports.ModalModule = ModalModule;
    return module.exports;
});
System.registerDynamic("zero-blocks/core/touch", ["@angular/core"], true, function ($__require, exports, module) {
    /// <reference path="../../typings/globals/hammerjs/index.d.ts" />
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var EVENT_SUFFIX = "precise";
    /**
     * Touch gestures manager based on Hammer.js
     * Use with caution, this will track references for single manager per element. Very TBD. Much TODO.
     */
    var HammerGesturesManager = function () {
        function HammerGesturesManager(_zone) {
            this._zone = _zone;
            this._hammerManagers = [];
            /**
             * Event option defaults for each recognizer, see http://hammerjs.github.io/api/ for API listing.
             */
            this.hammerOptions = [{
                name: "pan",
                options: {
                    threshold: 0
                }
            }, {
                name: "pinch",
                options: {
                    enable: true
                }
            }, {
                name: "rotate",
                options: {
                    enable: true
                }
            }];
        }
        HammerGesturesManager.prototype.supports = function (eventName) {
            return eventName.toLowerCase().endsWith("." + EVENT_SUFFIX);
        };
        /**
         * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
         * Modeling after other event plugins for easy future modifications.
         */
        HammerGesturesManager.prototype.addEventListener = function (element, eventName, eventHandler, options) {
            if (options === void 0) {
                options = null;
            }
            var self = this;
            // Creating the manager bind events, must be done outside of angular
            return this._zone.runOutsideAngular(function () {
                // new Hammer is a shortcut for Manager with defaults
                var mc = new Hammer(element);
                for (var i = 0; i < self.hammerOptions.length; i++) {
                    mc.get(self.hammerOptions[i].name).set(self.hammerOptions[i].options);
                }
                var handler = function (eventObj) {
                    self._zone.run(function () {
                        eventHandler(eventObj);
                    });
                };
                mc.on(eventName, handler);
                return function () {
                    mc.off(eventName, handler);
                };
            });
        };
        /**
         * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
         * Modeling after other event plugins for easy future modifications.
         *
         * @param target Can be one of either window, body or document(fallback default).
         */
        HammerGesturesManager.prototype.addGlobalEventListener = function (target, eventName, eventHandler) {
            var self = this,
                element = this.getGlobalEventTarget(target);
            // Creating the manager bind events, must be done outside of angular
            return this._zone.runOutsideAngular(function () {
                // new Hammer is a shortcut for Manager with defaults
                var mc = new Hammer(element);
                self.addManagerForElement(element, mc);
                for (var i = 0; i < self.hammerOptions.length; i++) {
                    mc.get(self.hammerOptions[i].name).set(self.hammerOptions[i].options);
                }
                var handler = function (eventObj) {
                    self._zone.run(function () {
                        eventHandler(eventObj);
                    });
                };
                mc.on(eventName, handler);
                return function () {
                    mc.off(eventName, handler);
                };
            });
        };
        /** temp replacement for DOM.getGlobalEventTarget(target) because DI won't play nice for now */
        HammerGesturesManager.prototype.getGlobalEventTarget = function (target) {
            switch (target) {
                case "window":
                    return window;
                case "body":
                    return document.body;
                default:
                    return document;
            }
        };
        /**
         * Set HammerManager options.
         *
         * @param element The DOM element used to create the manager on.
         *
         * ### Example
         *
         * ```ts
         * manager.setManagerOption(myElem, "pan", { pointers: 1 });
         * ```
         */
        HammerGesturesManager.prototype.setManagerOption = function (element, event, options) {
            var manager = this.getManagerForElement(element);
            manager.get(event).set(options);
        };
        /**
         * Add an element and manager map to the internal collection.
         *
         * @param element The DOM element used to create the manager on.
         */
        HammerGesturesManager.prototype.addManagerForElement = function (element, manager) {
            this._hammerManagers.push({ element: element, manager: manager });
        };
        /**
         * Get HammerManager for the element or null
         *
         * @param element The DOM element used to create the manager on.
         */
        HammerGesturesManager.prototype.getManagerForElement = function (element) {
            var result = this._hammerManagers.filter(function (value, index, array) {
                return value.element === element;
            });
            return result.length ? result[0].manager : null;
        };
        /**
         * Destroys the HammerManager for the element, removing event listeners in the process.
         *
         * @param element The DOM element used to create the manager on.
         */
        HammerGesturesManager.prototype.removeManagerForElement = function (element) {
            var index = null;
            for (var i = 0; i < this._hammerManagers.length; i++) {
                if (element === this._hammerManagers[i].element) {
                    index = i;
                    break;
                }
            }
            if (index !== null) {
                var item = this._hammerManagers.splice(index, 1)[0];
                // destroy also
                item.manager.destroy();
            }
        };
        /** Destroys all internally tracked HammerManagers, removing event listeners in the process. */
        HammerGesturesManager.prototype.destroy = function () {
            for (var i = 0; i < this._hammerManagers.length; i++) {
                this._hammerManagers[i].manager.destroy();
            }
            this._hammerManagers = [];
        };
        HammerGesturesManager = __decorate([core_1.Injectable(), __metadata('design:paramtypes', [core_1.NgZone])], HammerGesturesManager);
        return HammerGesturesManager;
    }();
    exports.HammerGesturesManager = HammerGesturesManager;
    return module.exports;
});
System.registerDynamic("zero-blocks/button/button", ["@angular/core"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var IgButton = function () {
        function IgButton(_el, _renderer) {
            this._el = _el;
            this._renderer = _renderer;
            this._type = 'flat';
            this._cssClass = 'ig-button';
        }
        Object.defineProperty(IgButton.prototype, "type", {
            set: function (value) {
                this._type = value || this._type;
                this._renderer.setElementClass(this._el.nativeElement, this._cssClass + "--" + this._type, true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgButton.prototype, "color", {
            set: function (value) {
                this._color = value || this._el.nativeElement.style.color;
                this._renderer.setElementStyle(this._el.nativeElement, 'color', this._color);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgButton.prototype, "background", {
            set: function (value) {
                this._backgroundColor = value || this._backgroundColor;
                this._renderer.setElementStyle(this._el.nativeElement, 'background', this._backgroundColor);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgButton.prototype, "disabled", {
            set: function (val) {
                this._renderer.setElementClass(this._el.nativeElement, this._cssClass + "--disabled", !!val);
            },
            enumerable: true,
            configurable: true
        });
        __decorate([core_1.Input('igButton'), __metadata('design:type', String), __metadata('design:paramtypes', [String])], IgButton.prototype, "type", null);
        __decorate([core_1.Input('igButtonColor'), __metadata('design:type', String), __metadata('design:paramtypes', [String])], IgButton.prototype, "color", null);
        __decorate([core_1.Input('igButtonBackground'), __metadata('design:type', String), __metadata('design:paramtypes', [String])], IgButton.prototype, "background", null);
        __decorate([core_1.Input(), __metadata('design:type', Object), __metadata('design:paramtypes', [Object])], IgButton.prototype, "disabled", null);
        IgButton = __decorate([core_1.Directive({
            selector: '[igButton]',
            host: {
                'role': 'button'
            }
        }), __metadata('design:paramtypes', [core_1.ElementRef, core_1.Renderer])], IgButton);
        return IgButton;
    }();
    exports.IgButton = IgButton;
    var ButtonModule = function () {
        function ButtonModule() {}
        ButtonModule = __decorate([core_1.NgModule({
            declarations: [IgButton],
            exports: [IgButton]
        }), __metadata('design:paramtypes', [])], ButtonModule);
        return ButtonModule;
    }();
    exports.ButtonModule = ButtonModule;
    return module.exports;
});
System.registerDynamic("zero-blocks/navbar/navbar", ["@angular/core", "../core/touch", "@angular/common", "../button/button"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var touch_1 = $__require("../core/touch");
    var common_1 = $__require("@angular/common");
    var button_1 = $__require("../button/button");
    var Navbar = function () {
        function Navbar(_location) {
            this._location = _location;
        }
        Navbar.prototype.canGoBack = function () {
            var isStackHisoryEmpty = window.history.length == 0;
            return isStackHisoryEmpty;
        };
        Navbar.prototype.navigateBack = function ($event) {
            this._location.back();
        };
        Navbar.prototype.hasIcon = function () {
            return this.icon != undefined;
        };
        __decorate([core_1.Input(), __metadata('design:type', String)], Navbar.prototype, "title", void 0);
        __decorate([core_1.Input('icon'), __metadata('design:type', String)], Navbar.prototype, "icon", void 0);
        Navbar = __decorate([core_1.Component({
            selector: "ig-navbar",
            moduleId: module.id,
            template: "\n      <nav class=\"ig-navbar\">\n      \t<span class=\"ig-navbar__left-btn\" [class.ig-navbar__left-btn--disabled]=\"canGoBack() || !hasIcon()\"> \n              <button igButton=\"navbar\" (click)=\"navigateBack($event)\">\n                  <i class=\"material-icons\">{{ icon }}</i>\n              </button>\n          </span>\n      \t<span>\n              <h1 class=\"ig-navbar__title\">{{ title }}</h1>\n          </span>\n      \t<ng-content></ng-content>\n      </nav>\n    ",
            providers: [touch_1.HammerGesturesManager]
        }), __metadata('design:paramtypes', [common_1.Location])], Navbar);
        return Navbar;
    }();
    exports.Navbar = Navbar;
    var NavbarModule = function () {
        function NavbarModule() {}
        NavbarModule = __decorate([core_1.NgModule({
            imports: [button_1.ButtonModule],
            declarations: [Navbar],
            exports: [Navbar]
        }), __metadata('design:paramtypes', [])], NavbarModule);
        return NavbarModule;
    }();
    exports.NavbarModule = NavbarModule;
    return module.exports;
});
System.registerDynamic("zero-blocks/directives/filter", ["@angular/core", "@angular/common"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var common_1 = $__require("@angular/common");
    var FilterDirective = function () {
        function FilterDirective(element, renderer) {
            this.element = element;
            this.filtering = new core_1.EventEmitter(false); // synchronous event emitter
            this.filtered = new core_1.EventEmitter();
        }
        FilterDirective.prototype.ngOnChanges = function (changes) {
            // Detect only changes of input value
            if (changes["filterOptions"] && changes["filterOptions"].currentValue && changes["filterOptions"].currentValue["inputValue"] !== undefined && changes["filterOptions"].previousValue && changes["filterOptions"].currentValue["inputValue"] !== changes["filterOptions"].previousValue["inputValue"]) {
                this.filter();
            }
        };
        FilterDirective.prototype.filter = function () {
            if (!this.filterOptions.items) {
                return;
            }
            var args = { cancel: false, items: this.filterOptions.items };
            this.filtering.emit(args);
            if (args.cancel) {
                return;
            }
            var pipe = new FilterPipe();
            var filtered = pipe.transform(this.filterOptions.items, this.filterOptions);
            this.filtered.emit({ filteredItems: filtered });
        };
        __decorate([core_1.Output(), __metadata('design:type', Object)], FilterDirective.prototype, "filtering", void 0);
        __decorate([
        // synchronous event emitter
        core_1.Output(), __metadata('design:type', Object)], FilterDirective.prototype, "filtered", void 0);
        __decorate([core_1.Input("filter"), __metadata('design:type', FilterOptions)], FilterDirective.prototype, "filterOptions", void 0);
        FilterDirective = __decorate([core_1.Directive({
            selector: '[filter]'
        }), __metadata('design:paramtypes', [core_1.ElementRef, core_1.Renderer])], FilterDirective);
        return FilterDirective;
    }();
    exports.FilterDirective = FilterDirective;
    var FilterPipe = function () {
        function FilterPipe() {}
        FilterPipe.prototype.transform = function (items,
        // options - initial settings of filter functionality
        options) {
            var result = [];
            if (!items || !items.length || !options) {
                return;
            }
            if (options.items) {
                items = options.items;
            }
            result = items.filter(function (item) {
                var match = options.matchFn(options.formatter(options.get_value(item, options.key)), options.inputValue);
                if (match) {
                    if (options.metConditionFn) {
                        options.metConditionFn(item);
                    }
                } else {
                    if (options.overdueConditionFn) {
                        options.overdueConditionFn(item);
                    }
                }
                return match;
            });
            return result;
        };
        FilterPipe = __decorate([core_1.Pipe({
            name: "filter",
            pure: false
        }), __metadata('design:paramtypes', [])], FilterPipe);
        return FilterPipe;
    }();
    exports.FilterPipe = FilterPipe;
    var FilterOptions = function () {
        function FilterOptions() {
            // Input text value that will be used as a filtering pattern (matching condition is based on it)
            this.inputValue = "";
        }
        // Function - get value to be tested from the item
        // item - single item of the list to be filtered
        // key - property name of item, which value should be tested
        // Default behavior - returns "key"- named property value of item if key si provided, otherwise textContent of the item's html element
        FilterOptions.prototype.get_value = function (item, key) {
            var result = "";
            if (key) {
                result = item[key].toString();
            } else if (item.element && item.element.nativeElement) {
                result = item.element.nativeElement.textContent.trim();
            }
            return result;
        };
        // Function - formats the original text before matching process
        // Default behavior - returns text to lower case
        FilterOptions.prototype.formatter = function (valueToTest) {
            return valueToTest.toLowerCase();
        };
        ;
        // Function - determines whether the item met the condition
        // valueToTest - text value that should be tested
        // inputValue - text value from input that condition is based on
        // Default behavior - "contains"
        FilterOptions.prototype.matchFn = function (valueToTest, inputValue) {
            return valueToTest.indexOf(inputValue && inputValue.toLowerCase() || "") > -1;
        };
        ;
        // Function - executed after matching test for every matched item
        // Default behavior - shows the item
        FilterOptions.prototype.metConditionFn = function (item) {
            if (item.hasOwnProperty("hidden")) {
                item.hidden = false;
            }
        };
        ;
        // Function - executed for every NOT matched item after matching test
        // Default behavior - hides the item
        FilterOptions.prototype.overdueConditionFn = function (item) {
            if (item.hasOwnProperty("hidden")) {
                item.hidden = true;
            }
        };
        ;
        return FilterOptions;
    }();
    exports.FilterOptions = FilterOptions;
    var FilterModule = function () {
        function FilterModule() {}
        FilterModule = __decorate([core_1.NgModule({
            declarations: [FilterDirective, FilterPipe],
            imports: [common_1.CommonModule],
            exports: [FilterDirective, FilterPipe]
        }), __metadata('design:paramtypes', [])], FilterModule);
        return FilterModule;
    }();
    exports.FilterModule = FilterModule;
    return module.exports;
});
System.registerDynamic("zero-blocks/directives/ripple", ["@angular/core", "@angular/common"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var common_1 = $__require("@angular/common");
    var RippleDirective = function () {
        function RippleDirective(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            this._centered = false;
            this._remaining = 0;
            this.rippleTarget = "";
            this.rippleDuration = 600;
            this.container = el.nativeElement;
        }
        Object.defineProperty(RippleDirective.prototype, "centered", {
            set: function (value) {
                this._centered = value || this.centered;
            },
            enumerable: true,
            configurable: true
        });
        RippleDirective.prototype.onMouseDown = function (event) {
            this._ripple(event);
        };
        RippleDirective.prototype._ripple = function (event) {
            var _this = this;
            var target, x, y, rippler, rectBounds;
            if (this.rippleTarget) {
                target = this.container.querySelector(this.rippleTarget) || this.container;
            } else {
                target = this.container;
            }
            rectBounds = target.getBoundingClientRect();
            var top = rectBounds.top,
                left = rectBounds.left,
                width = rectBounds.width,
                height = rectBounds.height;
            // Take into account viewport scroll
            top += window.scrollY;
            left += window.scrollX;
            this.renderer.setElementClass(target, 'ig-ripple-host', true);
            rippler = this.renderer.createElement(target, 'span');
            this.renderer.setElementClass(rippler, 'ig-ripple-host__ripple', true);
            if (width >= height) {
                height = width;
            } else {
                width = height;
            }
            x = event.pageX - left - width / 2;
            y = event.pageY - top - height / 2;
            this.renderer.setElementStyle(rippler, 'width', width + "px");
            this.renderer.setElementStyle(rippler, 'height', height + "px");
            this.renderer.setElementStyle(rippler, 'top', y + "px");
            this.renderer.setElementStyle(rippler, 'left', x + "px");
            if (this._centered) {
                this.renderer.setElementStyle(rippler, 'top', '0');
                this.renderer.setElementStyle(rippler, 'left', '0');
            }
            if (this.rippleColor) {
                this.renderer.setElementStyle(rippler, 'background', this.rippleColor);
            }
            var FRAMES = [{ opacity: 0.5, transform: 'scale(0)' }, { opacity: 0, transform: 'scale(2)' }];
            var animation = rippler.animate(FRAMES, this.rippleDuration);
            this._remaining++;
            animation.onfinish = function (ev) {
                target.removeChild(rippler);
                _this._remaining--;
                if (_this._remaining <= 0) {
                    _this.renderer.setElementClass(target, 'ig-ripple-host', false);
                }
            };
        };
        __decorate([core_1.Input("igRippleTarget"), __metadata('design:type', String)], RippleDirective.prototype, "rippleTarget", void 0);
        __decorate([core_1.Input('igRippleCentered'), __metadata('design:type', Boolean), __metadata('design:paramtypes', [Boolean])], RippleDirective.prototype, "centered", null);
        __decorate([core_1.Input('igRipple'), __metadata('design:type', String)], RippleDirective.prototype, "rippleColor", void 0);
        __decorate([core_1.Input('igRippleDuration'), __metadata('design:type', Number)], RippleDirective.prototype, "rippleDuration", void 0);
        __decorate([core_1.HostListener('mousedown', ['$event']), __metadata('design:type', Function), __metadata('design:paramtypes', [Object]), __metadata('design:returntype', void 0)], RippleDirective.prototype, "onMouseDown", null);
        RippleDirective = __decorate([core_1.Directive({
            selector: '[igRipple]'
        }), __metadata('design:paramtypes', [core_1.ElementRef, core_1.Renderer])], RippleDirective);
        return RippleDirective;
    }();
    var IgRippleModule = function () {
        function IgRippleModule() {}
        IgRippleModule = __decorate([core_1.NgModule({
            declarations: [RippleDirective],
            imports: [common_1.CommonModule],
            exports: [RippleDirective]
        }), __metadata('design:paramtypes', [])], IgRippleModule);
        return IgRippleModule;
    }();
    exports.IgRippleModule = IgRippleModule;
    return module.exports;
});
System.registerDynamic("zero-blocks/badge/badge", ["@angular/core", "@angular/common"], true, function ($__require, exports, module) {
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = this && this.__metadata || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1 = $__require("@angular/core");
    var common_1 = $__require("@angular/common");
    (function (Type) {
        Type[Type["DEFAULT"] = 0] = "DEFAULT";
        Type[Type["INFO"] = 1] = "INFO";
        Type[Type["SUCCESS"] = 2] = "SUCCESS";
        Type[Type["WARNING"] = 3] = "WARNING";
        Type[Type["ERROR"] = 4] = "ERROR";
    })(exports.Type || (exports.Type = {}));
    var Type = exports.Type;
    var Badge = function () {
        function Badge() {
            this._type = "";
            this.TypeEnum = Type;
        }
        Object.defineProperty(Badge.prototype, "type", {
            get: function () {
                return this._type === undefined ? "default" : this._type;
            },
            set: function (value) {
                var sizeType = this.TypeEnum[value.toUpperCase()];
                if (sizeType === undefined) {
                    this._type = "default";
                } else {
                    this._type = value.toLowerCase();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Badge.prototype, "value", {
            get: function () {
                return this._value === undefined ? "?" : this._value;
            },
            set: function (value) {
                if (value === undefined) {
                    this._value = "-";
                } else {
                    this._value = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Badge.prototype, "iconBdg", {
            get: function () {
                return this._iconBdg;
            },
            set: function (value) {
                this._iconBdg = value;
            },
            enumerable: true,
            configurable: true
        });
        Badge.prototype.setClasses = function () {
            var classes = {};
            switch (this.TypeEnum[this._type.toUpperCase()]) {
                case Type.DEFAULT:
                    classes = {
                        "ig-badge__circle--default": true
                    };
                    break;
                case Type.INFO:
                    classes = {
                        "ig-badge__circle--info": true
                    };
                    break;
                case Type.SUCCESS:
                    classes = {
                        "ig-badge__circle--success": true
                    };
                    break;
                case Type.WARNING:
                    classes = {
                        "ig-badge__circle--warning": true
                    };
                    break;
                case Type.ERROR:
                    classes = {
                        "ig-badge__circle--error": true
                    };
                    break;
            }
            return classes;
        };
        __decorate([core_1.Input("type"), __metadata('design:type', String)], Badge.prototype, "type", null);
        __decorate([core_1.Input("value"), __metadata('design:type', String)], Badge.prototype, "value", null);
        __decorate([core_1.Input("icon"), __metadata('design:type', String)], Badge.prototype, "iconBdg", null);
        Badge = __decorate([core_1.Component({
            selector: 'ig-badge',
            moduleId: module.id,
            template: "\n      <div class=\"ig-badge\">\n      \t<div class=\"ig-badge__circle\" [ngClass]=\"setClasses()\">\n      \t\t<span *ngIf=\"!iconBdg\" class=\"ig-badge__circle-value\">{{value}}</span>\n      \t\t<i *ngIf=\"iconBdg\" class=\"material-icons ig-badge__circle-value\">{{iconBdg}}</i>\n      \t</div>\n      </div>\n    "
        }), __metadata('design:paramtypes', [])], Badge);
        return Badge;
    }();
    exports.Badge = Badge;
    var BadgeModule = function () {
        function BadgeModule() {}
        BadgeModule = __decorate([core_1.NgModule({
            declarations: [Badge],
            imports: [common_1.CommonModule],
            exports: [Badge]
        }), __metadata('design:paramtypes', [])], BadgeModule);
        return BadgeModule;
    }();
    exports.BadgeModule = BadgeModule;
    return module.exports;
});
System.registerDynamic('zero-blocks/main', ['./core/navigation', './navigation-drawer/navigation-drawer', './icon/icon', './button/button', './list/list', './tabbar/tab', './carousel/carousel', './input/input', './checkbox/checkbox', './radio/radio', './label/label', './switch/switch', './avatar/avatar', './layout/layout', './modal/modal', './navbar/navbar', './directives/filter', './directives/ripple', './badge/badge'], true, function ($__require, exports, module) {
  "use strict";

  var define,
      global = this || self,
      GLOBAL = global;
  function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
  /**
   * Public API facet
   */
  __export($__require('./core/navigation'));
  __export($__require('./navigation-drawer/navigation-drawer'));
  __export($__require('./icon/icon'));
  __export($__require('./button/button'));
  __export($__require('./list/list'));
  __export($__require('./tabbar/tab'));
  __export($__require('./carousel/carousel'));
  __export($__require('./input/input'));
  __export($__require('./checkbox/checkbox'));
  __export($__require('./radio/radio'));
  __export($__require('./label/label'));
  __export($__require('./switch/switch'));
  __export($__require('./avatar/avatar'));
  __export($__require('./layout/layout'));
  __export($__require('./modal/modal'));
  __export($__require('./navbar/navbar'));
  __export($__require('./directives/filter'));
  __export($__require('./directives/ripple'));
  __export($__require('./badge/badge'));
  return module.exports;
});